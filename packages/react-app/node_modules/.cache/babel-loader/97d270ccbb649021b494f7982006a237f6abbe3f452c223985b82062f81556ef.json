{"ast":null,"code":"import { getAddress } from 'ethers/lib/utils';\nimport { useConnector } from '../providers/network/connectors';\nimport { useConfig } from '../hooks';\nimport { useReadonlyNetwork } from './useReadonlyProvider';\nimport { useEffect, useState } from 'react';\nimport { useReadonlyNetworkStates } from '../providers/network/readonlyNetworks/context';\n/**\n * Returns connection state and functions that allow to manipulate the state.\n * **Requires**: `<ConfigProvider>`\n *\n * @public\n * @returns {} Object with the following:\n    - `account: string` - current user account (or *undefined* if not connected)\n    - `chainId: ChainId` - current chainId (or *undefined* if not connected)\n    - `library: Web3Provider` - an instance of ethers [Web3Provider](https://github.com/TrueFiEng/useDApp/tree/master/packages/example) (or `undefined` if not connected)\n    - `active: boolean` - returns if provider is connected (read or write mode)\n    - `activateBrowserWallet()` - function that will initiate connection to browser web3 extension (e.g. Metamask)\n    - `async activate(connector: AbstractConnector, onError?: (error: Error) => void, throwErrors?: boolean)` - function that allows to connect to a wallet\n    - `async deactivate()` - function that disconnects wallet\n    - `error?: Error` - an error that occurred during connecting (e.g. connection is broken, unsupported network)\n */\nexport function useEthers() {\n  var _a;\n  const {\n    connector,\n    deactivate,\n    activate,\n    activateBrowserWallet,\n    isLoading\n  } = useConnector();\n  const readonlyNetwork = useReadonlyNetwork();\n  const [errors, setErrors] = useState((_a = connector === null || connector === void 0 ? void 0 : connector.errors) !== null && _a !== void 0 ? _a : []);\n  const [account, setAccount] = useState(getAccount(connector));\n  const [provider, setProvider] = useState(connector === null || connector === void 0 ? void 0 : connector.getProvider());\n  const [chainId, setChainId] = useState(connector === null || connector === void 0 ? void 0 : connector.chainId);\n  useEffect(() => {\n    if (!(connector === null || connector === void 0 ? void 0 : connector.getProvider())) {\n      setAccount(undefined);\n      setProvider(readonlyNetwork === null || readonlyNetwork === void 0 ? void 0 : readonlyNetwork.provider);\n      setChainId(readonlyNetwork === null || readonlyNetwork === void 0 ? void 0 : readonlyNetwork.chainId);\n      setErrors([]);\n      return;\n    }\n    setChainId(connector.chainId);\n    setErrors(connector.errors);\n    setProvider(connector.getProvider());\n    setAccount(getAccount(connector));\n    return connector.updated.on(_ref => {\n      let {\n        chainId,\n        errors,\n        accounts\n      } = _ref;\n      setChainId(chainId);\n      setErrors(errors);\n      if (accounts[0]) {\n        setAccount(getAddress(accounts[0]));\n      } else {\n        setAccount(undefined);\n      }\n    });\n  }, [connector]);\n  const {\n    networks,\n    readOnlyUrls\n  } = useConfig();\n  const [error, setError] = useState(undefined);\n  const networkStates = useReadonlyNetworkStates();\n  const configuredChainIds = Object.keys(readOnlyUrls || {}).map(chainId => parseInt(chainId, 10));\n  const supportedChainIds = networks === null || networks === void 0 ? void 0 : networks.map(network => network.chainId);\n  useEffect(() => {\n    const isNotConfiguredChainId = chainId && configuredChainIds && configuredChainIds.indexOf(chainId) < 0;\n    const isUnsupportedChainId = chainId && supportedChainIds && supportedChainIds.indexOf(chainId) < 0;\n    if (isUnsupportedChainId || isNotConfiguredChainId) {\n      const chainIdError = new Error(`${isUnsupportedChainId ? 'Unsupported' : 'Not configured'} chain id: ${chainId}.`);\n      chainIdError.name = 'ChainIdError';\n      setError(chainIdError);\n      return;\n    }\n    for (const networkState of Object.values(networkStates)) {\n      if (networkState.errors.length > 0) {\n        setError(networkState.errors[networkState.errors.length - 1]);\n        return;\n      }\n    }\n    setError(errors === null || errors === void 0 ? void 0 : errors[errors.length - 1]);\n  }, [chainId, errors, networkStates]);\n  return {\n    connector: undefined,\n    library: provider,\n    chainId: (error === null || error === void 0 ? void 0 : error.name) === 'ChainIdError' ? undefined : provider !== undefined ? chainId : readonlyNetwork === null || readonlyNetwork === void 0 ? void 0 : readonlyNetwork.chainId,\n    account,\n    active: !!provider,\n    activate: async providerOrConnector => {\n      if ('getProvider' in providerOrConnector) {\n        console.warn('Using web3-react connectors is deprecated and may lead to unexpected behavior.');\n        await providerOrConnector.activate();\n        return activate(await providerOrConnector.getProvider());\n      }\n      return activate(providerOrConnector);\n    },\n    activateBrowserWallet,\n    deactivate,\n    setError: () => {\n      throw new Error('setError is deprecated');\n    },\n    error,\n    isLoading,\n    switchNetwork: async chainId => {\n      await (connector === null || connector === void 0 ? void 0 : connector.switchNetwork(chainId));\n    }\n  };\n}\nconst getAccount = connector => {\n  if (connector === null || connector === void 0 ? void 0 : connector.accounts[0]) {\n    return getAddress(connector.accounts[0]);\n  }\n  return undefined;\n};","map":{"version":3,"mappings":"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","names":["getAddress","useConnector","useConfig","useReadonlyNetwork","useEffect","useState","useReadonlyNetworkStates","useEthers","connector","deactivate","activate","activateBrowserWallet","isLoading","readonlyNetwork","errors","setErrors","account","setAccount","getAccount","provider","setProvider","getProvider","chainId","setChainId","undefined","updated","on","accounts","networks","readOnlyUrls","error","setError","networkStates","configuredChainIds","Object","keys","map","parseInt","supportedChainIds","network","isNotConfiguredChainId","indexOf","isUnsupportedChainId","chainIdError","Error","name","networkState","values","length","library","active","providerOrConnector","console","warn","switchNetwork"],"sources":["/Users/jaleltounsi/Documents/GitHub/apexwave.fi/apexwave/node_modules/@usedapp/core/src/hooks/useEthers.ts"],"sourcesContent":["import { providers } from 'ethers'\nimport { getAddress } from 'ethers/lib/utils'\nimport { Connector, ConnectorController, useConnector } from '../providers/network/connectors'\nimport { useConfig } from '../hooks'\nimport { useReadonlyNetwork } from './useReadonlyProvider'\nimport { useEffect, useState } from 'react'\nimport { useReadonlyNetworkStates } from '../providers/network/readonlyNetworks/context'\nimport { ActivateBrowserWallet } from '../providers/network/connectors/context'\n\ntype JsonRpcProvider = providers.JsonRpcProvider\ntype Web3Provider = providers.Web3Provider\ntype ExternalProvider = providers.ExternalProvider\ntype FallBackProvider = providers.FallbackProvider\n\ntype MaybePromise<T> = Promise<T> | T\n\ntype SupportedProviders =\n  | JsonRpcProvider\n  | ExternalProvider\n  | { getProvider: () => MaybePromise<JsonRpcProvider | ExternalProvider>; activate: () => Promise<any> }\n  | Connector\n\n/**\n * useEthers return type.\n */\nexport type Web3Ethers = {\n  activate: (provider: SupportedProviders) => Promise<void>\n  /**\n   * @deprecated\n   */\n  setError: (error: Error) => void\n  deactivate: () => void\n  connector: undefined\n  chainId?: number\n  account?: string\n  error?: Error\n  library?: JsonRpcProvider | FallBackProvider\n  active: boolean\n  activateBrowserWallet: ActivateBrowserWallet\n  isLoading: boolean\n  /**\n   * Switch to a different network.\n   */\n  switchNetwork: (chainId: number) => Promise<void>\n}\n\n/**\n * Returns connection state and functions that allow to manipulate the state.\n * **Requires**: `<ConfigProvider>`\n * \n * @public\n * @returns {} Object with the following:\n    - `account: string` - current user account (or *undefined* if not connected)\n    - `chainId: ChainId` - current chainId (or *undefined* if not connected)\n    - `library: Web3Provider` - an instance of ethers [Web3Provider](https://github.com/TrueFiEng/useDApp/tree/master/packages/example) (or `undefined` if not connected)\n    - `active: boolean` - returns if provider is connected (read or write mode)\n    - `activateBrowserWallet()` - function that will initiate connection to browser web3 extension (e.g. Metamask)\n    - `async activate(connector: AbstractConnector, onError?: (error: Error) => void, throwErrors?: boolean)` - function that allows to connect to a wallet\n    - `async deactivate()` - function that disconnects wallet\n    - `error?: Error` - an error that occurred during connecting (e.g. connection is broken, unsupported network)\n */\nexport function useEthers(): Web3Ethers {\n  const { connector, deactivate, activate, activateBrowserWallet, isLoading } = useConnector()\n  const readonlyNetwork = useReadonlyNetwork()\n\n  const [errors, setErrors] = useState<Error[]>(connector?.errors ?? [])\n  const [account, setAccount] = useState<string | undefined>(getAccount(connector))\n  const [provider, setProvider] = useState<JsonRpcProvider | Web3Provider | FallBackProvider | undefined>(\n    connector?.getProvider()\n  )\n  const [chainId, setChainId] = useState<number | undefined>(connector?.chainId)\n\n  useEffect(() => {\n    if (!connector?.getProvider()) {\n      setAccount(undefined)\n      setProvider(readonlyNetwork?.provider as JsonRpcProvider | FallBackProvider | undefined)\n      setChainId(readonlyNetwork?.chainId)\n      setErrors([])\n      return\n    }\n\n    setChainId(connector.chainId)\n    setErrors(connector.errors)\n    setProvider(connector.getProvider())\n    setAccount(getAccount(connector))\n\n    return connector.updated.on(({ chainId, errors, accounts }) => {\n      setChainId(chainId)\n      setErrors(errors)\n      if (accounts[0]) {\n        setAccount(getAddress(accounts[0]))\n      } else {\n        setAccount(undefined)\n      }\n    })\n  }, [connector])\n\n  const { networks, readOnlyUrls } = useConfig()\n  const [error, setError] = useState<Error | undefined>(undefined)\n\n  const networkStates = useReadonlyNetworkStates()\n\n  const configuredChainIds = Object.keys(readOnlyUrls || {}).map((chainId) => parseInt(chainId, 10))\n  const supportedChainIds = networks?.map((network) => network.chainId)\n\n  useEffect(() => {\n    const isNotConfiguredChainId = chainId && configuredChainIds && configuredChainIds.indexOf(chainId) < 0\n    const isUnsupportedChainId = chainId && supportedChainIds && supportedChainIds.indexOf(chainId) < 0\n\n    if (isUnsupportedChainId || isNotConfiguredChainId) {\n      const chainIdError = new Error(`${isUnsupportedChainId ? 'Unsupported' : 'Not configured'} chain id: ${chainId}.`)\n      chainIdError.name = 'ChainIdError'\n      setError(chainIdError)\n      return\n    }\n\n    for (const networkState of Object.values(networkStates)) {\n      if (networkState.errors.length > 0) {\n        setError(networkState.errors[networkState.errors.length - 1])\n        return\n      }\n    }\n\n    setError(errors?.[errors.length - 1])\n  }, [chainId, errors, networkStates])\n\n  return {\n    connector: undefined,\n    library: provider,\n    chainId: error?.name === 'ChainIdError' ? undefined : provider !== undefined ? chainId : readonlyNetwork?.chainId,\n    account,\n    active: !!provider,\n    activate: async (providerOrConnector: SupportedProviders) => {\n      if ('getProvider' in providerOrConnector) {\n        console.warn('Using web3-react connectors is deprecated and may lead to unexpected behavior.')\n        await providerOrConnector.activate()\n        return activate(await providerOrConnector.getProvider())\n      }\n      return activate(providerOrConnector)\n    },\n    activateBrowserWallet,\n    deactivate,\n\n    setError: () => {\n      throw new Error('setError is deprecated')\n    },\n\n    error,\n    isLoading,\n    switchNetwork: async (chainId: number) => {\n      await connector?.switchNetwork(chainId)\n    },\n  }\n}\n\nconst getAccount = (connector: ConnectorController | undefined) => {\n  if (connector?.accounts[0]) {\n    return getAddress(connector.accounts[0])\n  }\n  return undefined\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}