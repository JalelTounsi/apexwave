{"ast":null,"code":"import { useConfig } from './useConfig';\nimport { BigNumber } from 'ethers';\nimport { useCallback, useState } from 'react';\nimport { useEthers } from './useEthers';\nimport { estimateContractFunctionGasLimit, usePromiseTransaction } from './usePromiseTransaction';\nimport { useReadonlyNetworks } from '../providers';\nimport { getSignerFromOptions } from '../helpers/getSignerFromOptions';\n/**\n * @internal Intended for internal use - use it on your own risk\n */\nexport function connectContractToSigner(contract, options, librarySigner) {\n  if (contract.signer) {\n    return contract;\n  }\n  if (options && 'signer' in options) {\n    return contract.connect(options.signer);\n  }\n  if (librarySigner) {\n    return contract.connect(librarySigner);\n  }\n  throw new TypeError('No signer available in contract, options or library');\n}\n/**\n * Hook returns an object with four variables: ``state`` , ``send``, ``events`` , and ``resetState``.\n *\n * The `state` represents the status of transaction. See {@link TransactionStatus}.\n *\n * `resetState` can be used to reset the state to `None` after a transaction attempt has either succeeded or failed.\n *\n * The `events` is a array of parsed transaction events of type [LogDescription](https://docs.ethers.io/v5/api/utils/abi/interface/#LogDescription).\n *\n * To send a transaction use `send` function returned by `useContractFunction`.\n * The function forwards arguments to ethers.js contract object, so that arguments map 1 to 1 with Solidity function arguments.\n * Additionally, there can be one extra argument - [TransactionOverrides](https://docs.ethers.io/v5/api/contract/contract/#contract-functionsSend), which can be used to manipulate transaction parameters like gasPrice, nonce, etc\n *\n * If typechain contract is supplied as contract parameter then function name and send arguments will be type checked.\n * More on type checking [here](https://usedapp-docs.netlify.app/docs/Guides/Reading/Typechain).\n * @public\n * @param contract contract which function is to be called , also see [Contract](https://docs.ethers.io/v5/api/contract/contract/)\n * @param functionName name of function to call\n * @param options additional options of type {@link TransactionOptions}\n * @returns {} object with variables: `send` , `state` , `events`: `{ send: (...args: any[]) => void, state: TransactionStatus, events: LogDescription[] }`.\n *\n * @example\n * const { state, send } = useContractFunction(contract, 'deposit', { transactionName: 'Wrap' })\n *\n * const depositEther = (etherAmount: string) => {\n *   send({ value: utils.parseEther(etherAmount) })\n * }\n * @example\n * const { state, send } = useContractFunction(contract, 'withdraw', { transactionName: 'Unwrap' })\n *\n * const withdrawEther = (wethAmount: string) => {\n *   send(utils.parseEther(wethAmount))\n * }\n */\nexport function useContractFunction(contract, functionName, options) {\n  var _a, _b, _c;\n  const {\n    library,\n    chainId\n  } = useEthers();\n  const transactionChainId = options && 'chainId' in options && (options === null || options === void 0 ? void 0 : options.chainId) || chainId;\n  const {\n    promiseTransaction,\n    state,\n    resetState\n  } = usePromiseTransaction(transactionChainId, options);\n  const [events, setEvents] = useState(undefined);\n  const config = useConfig();\n  const gasLimitBufferPercentage = (_c = (_b = (_a = options === null || options === void 0 ? void 0 : options.gasLimitBufferPercentage) !== null && _a !== void 0 ? _a : options === null || options === void 0 ? void 0 : options.bufferGasLimitPercentage) !== null && _b !== void 0 ? _b : config === null || config === void 0 ? void 0 : config.gasLimitBufferPercentage) !== null && _c !== void 0 ? _c : 0;\n  const providers = useReadonlyNetworks();\n  const provider = transactionChainId && providers[transactionChainId];\n  const send = useCallback(async function () {\n    var _a;\n    if (contract) {\n      const numberOfArgs = contract.interface.getFunction(functionName).inputs.length;\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      const hasOpts = args.length > numberOfArgs;\n      if (args.length !== numberOfArgs && args.length !== numberOfArgs + 1) {\n        throw new Error(`Invalid number of arguments for function \"${functionName}\".`);\n      }\n      const signer = getSignerFromOptions(provider, options, library);\n      const contractWithSigner = connectContractToSigner(contract, options, signer);\n      const opts = hasOpts ? args[args.length - 1] : undefined;\n      const gasLimit = typeof opts === 'object' && Object.prototype.hasOwnProperty.call(opts, 'gasLimit') ? opts.gasLimit : (_a = await estimateContractFunctionGasLimit(contractWithSigner, functionName, args, gasLimitBufferPercentage)) !== null && _a !== void 0 ? _a : BigNumber.from(0);\n      const modifiedOpts = Object.assign({\n        gasLimit\n      }, opts);\n      const modifiedArgs = hasOpts ? args.slice(0, args.length - 1) : args;\n      const receipt = await promiseTransaction(contractWithSigner[functionName](...modifiedArgs, modifiedOpts), {\n        safeTransaction: {\n          to: contract.address,\n          value: opts === null || opts === void 0 ? void 0 : opts.value,\n          data: contract.interface.encodeFunctionData(functionName, modifiedArgs)\n        }\n      });\n      if (receipt === null || receipt === void 0 ? void 0 : receipt.logs) {\n        const events = receipt.logs.reduce((accumulatedLogs, log) => {\n          try {\n            return log.address.toLowerCase() === contract.address.toLowerCase() ? [...accumulatedLogs, contract.interface.parseLog(log)] : accumulatedLogs;\n          } catch (_err) {\n            return accumulatedLogs;\n          }\n        }, []);\n        setEvents(events);\n      }\n      return receipt;\n    }\n  }, [contract, functionName, options, provider, library, gasLimitBufferPercentage, promiseTransaction]);\n  return {\n    send,\n    state,\n    events,\n    resetState\n  };\n}","map":{"version":3,"mappings":"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","names":["useConfig","BigNumber","useCallback","useState","useEthers","estimateContractFunctionGasLimit","usePromiseTransaction","useReadonlyNetworks","getSignerFromOptions","connectContractToSigner","contract","options","librarySigner","signer","connect","TypeError","useContractFunction","functionName","library","chainId","transactionChainId","promiseTransaction","state","resetState","events","setEvents","undefined","config","gasLimitBufferPercentage","bufferGasLimitPercentage","providers","provider","send","numberOfArgs","interface","getFunction","inputs","length","args","hasOpts","Error","contractWithSigner","opts","gasLimit","Object","prototype","hasOwnProperty","call","from","modifiedOpts","modifiedArgs","slice","receipt","safeTransaction","to","address","value","data","encodeFunctionData","logs","reduce","accumulatedLogs","log","toLowerCase","parseLog","_err"],"sources":["/Users/jaleltounsi/Documents/GitHub/apexwave.fi/apexwave/node_modules/@usedapp/core/src/hooks/useContractFunction.ts"],"sourcesContent":["import { TransactionOptions } from '../model/TransactionOptions'\nimport { useConfig } from './useConfig'\nimport { Contract, Signer, providers, BigNumber } from 'ethers'\nimport { useCallback, useState } from 'react'\nimport { useEthers } from './useEthers'\nimport { estimateContractFunctionGasLimit, usePromiseTransaction } from './usePromiseTransaction'\nimport { LogDescription } from 'ethers/lib/utils'\nimport { ContractFunctionNames, Falsy, Params, TypedContract } from '../model/types'\nimport { TransactionReceipt } from '@ethersproject/abstract-provider'\nimport { useReadonlyNetworks } from '../providers'\nimport { ChainId } from '../constants'\nimport { getSignerFromOptions } from '../helpers/getSignerFromOptions'\n\n/**\n * @internal Intended for internal use - use it on your own risk\n */\nexport function connectContractToSigner(contract: Contract, options?: TransactionOptions, librarySigner?: Signer) {\n  if (contract.signer) {\n    return contract\n  }\n\n  if (options && 'signer' in options) {\n    return contract.connect(options.signer)\n  }\n\n  if (librarySigner) {\n    return contract.connect(librarySigner)\n  }\n\n  throw new TypeError('No signer available in contract, options or library')\n}\n\n/**\n * Hook returns an object with four variables: ``state`` , ``send``, ``events`` , and ``resetState``.\n *\n * The `state` represents the status of transaction. See {@link TransactionStatus}.\n *\n * `resetState` can be used to reset the state to `None` after a transaction attempt has either succeeded or failed.\n *\n * The `events` is a array of parsed transaction events of type [LogDescription](https://docs.ethers.io/v5/api/utils/abi/interface/#LogDescription).\n *\n * To send a transaction use `send` function returned by `useContractFunction`.\n * The function forwards arguments to ethers.js contract object, so that arguments map 1 to 1 with Solidity function arguments.\n * Additionally, there can be one extra argument - [TransactionOverrides](https://docs.ethers.io/v5/api/contract/contract/#contract-functionsSend), which can be used to manipulate transaction parameters like gasPrice, nonce, etc\n *\n * If typechain contract is supplied as contract parameter then function name and send arguments will be type checked.\n * More on type checking [here](https://usedapp-docs.netlify.app/docs/Guides/Reading/Typechain).\n * @public\n * @param contract contract which function is to be called , also see [Contract](https://docs.ethers.io/v5/api/contract/contract/)\n * @param functionName name of function to call\n * @param options additional options of type {@link TransactionOptions}\n * @returns {} object with variables: `send` , `state` , `events`: `{ send: (...args: any[]) => void, state: TransactionStatus, events: LogDescription[] }`.\n *\n * @example\n * const { state, send } = useContractFunction(contract, 'deposit', { transactionName: 'Wrap' })\n *\n * const depositEther = (etherAmount: string) => {\n *   send({ value: utils.parseEther(etherAmount) })\n * }\n * @example\n * const { state, send } = useContractFunction(contract, 'withdraw', { transactionName: 'Unwrap' })\n *\n * const withdrawEther = (wethAmount: string) => {\n *   send(utils.parseEther(wethAmount))\n * }\n */\nexport function useContractFunction<T extends TypedContract, FN extends ContractFunctionNames<T>>(\n  contract: T | Falsy,\n  functionName: FN,\n  options?: TransactionOptions\n) {\n  const { library, chainId } = useEthers()\n  const transactionChainId = (options && 'chainId' in options && options?.chainId) || chainId\n  const { promiseTransaction, state, resetState } = usePromiseTransaction(transactionChainId, options)\n  const [events, setEvents] = useState<LogDescription[] | undefined>(undefined)\n\n  const config = useConfig()\n  const gasLimitBufferPercentage =\n    options?.gasLimitBufferPercentage ?? options?.bufferGasLimitPercentage ?? config?.gasLimitBufferPercentage ?? 0\n\n  const providers = useReadonlyNetworks()\n  const provider = (transactionChainId && providers[transactionChainId as ChainId])!\n\n  const send = useCallback(\n    async (...args: Params<T, FN>): Promise<TransactionReceipt | undefined> => {\n      if (contract) {\n        const numberOfArgs = contract.interface.getFunction(functionName).inputs.length\n        const hasOpts = args.length > numberOfArgs\n        if (args.length !== numberOfArgs && args.length !== numberOfArgs + 1) {\n          throw new Error(`Invalid number of arguments for function \"${functionName}\".`)\n        }\n\n        const signer = getSignerFromOptions(provider as providers.BaseProvider, options, library)\n\n        const contractWithSigner = connectContractToSigner(contract, options, signer)\n        const opts = hasOpts ? args[args.length - 1] : undefined\n\n        const gasLimit =\n          typeof opts === 'object' && Object.prototype.hasOwnProperty.call(opts, 'gasLimit')\n            ? opts.gasLimit\n            : (await estimateContractFunctionGasLimit(\n                contractWithSigner,\n                functionName,\n                args,\n                gasLimitBufferPercentage\n              )) ?? BigNumber.from(0)\n\n        const modifiedOpts = {\n          gasLimit,\n          ...opts,\n        }\n        const modifiedArgs = hasOpts ? args.slice(0, args.length - 1) : args\n\n        const receipt = await promiseTransaction(contractWithSigner[functionName](...modifiedArgs, modifiedOpts), {\n          safeTransaction: {\n            to: contract.address,\n            value: opts?.value,\n            data: contract.interface.encodeFunctionData(functionName, modifiedArgs),\n          },\n        })\n        if (receipt?.logs) {\n          const events = receipt.logs.reduce((accumulatedLogs, log) => {\n            try {\n              return log.address.toLowerCase() === contract.address.toLowerCase()\n                ? [...accumulatedLogs, contract.interface.parseLog(log)]\n                : accumulatedLogs\n            } catch (_err) {\n              return accumulatedLogs\n            }\n          }, [] as LogDescription[])\n          setEvents(events)\n        }\n        return receipt\n      }\n    },\n    [contract, functionName, options, provider, library, gasLimitBufferPercentage, promiseTransaction]\n  )\n\n  return { send, state, events, resetState }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}