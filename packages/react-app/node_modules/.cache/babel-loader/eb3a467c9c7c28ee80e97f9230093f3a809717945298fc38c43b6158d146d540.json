{"ast":null,"code":"import { jsx as _jsx } from \"react/jsx-runtime\";\nimport { useCallback, useEffect, useMemo, useReducer, useState } from 'react';\nimport { providers } from 'ethers';\nimport { useConfig } from '../../../hooks';\nimport { ReadonlyNetworksContext } from './context';\nimport { fromEntries } from '../../../helpers/fromEntries';\nimport { networkStatesReducer } from './reducer';\nimport { useWindow } from '../../window';\nimport { isWebSocketProvider } from '../../../helpers';\nconst {\n  Provider,\n  StaticJsonRpcProvider\n} = providers;\nconst getProviderFromConfig = urlOrProviderOrProviderFunction => {\n  if (Provider.isProvider(urlOrProviderOrProviderFunction)) {\n    return urlOrProviderOrProviderFunction;\n  }\n  if (typeof urlOrProviderOrProviderFunction === 'function') {\n    return urlOrProviderOrProviderFunction();\n  }\n  return new StaticJsonRpcProvider(urlOrProviderOrProviderFunction);\n};\nexport const getProvidersFromConfig = readOnlyUrls => fromEntries(Object.entries(readOnlyUrls).map(_ref => {\n  let [chainId, urlOrProviderOrProviderFunction] = _ref;\n  return [chainId, getProviderFromConfig(urlOrProviderOrProviderFunction)];\n}));\nexport function ReadonlyNetworksProvider(_ref2) {\n  let {\n    providerOverrides = {},\n    children\n  } = _ref2;\n  const {\n    readOnlyUrls = {},\n    pollingInterval,\n    pollingIntervals\n  } = useConfig();\n  const isActive = useWindow();\n  const [providers, setProviders] = useState(() => Object.assign(Object.assign({}, getProvidersFromConfig(readOnlyUrls)), providerOverrides));\n  const [networkStates, dispatchNetworkState] = useReducer(networkStatesReducer, Object.assign({}, fromEntries(Object.keys(Object.assign(Object.assign({}, readOnlyUrls), providerOverrides)).map(chainId => [chainId, {\n    errors: []\n  }]))));\n  const getPollingInterval = useCallback(chainId => {\n    var _a;\n    return (_a = pollingIntervals === null || pollingIntervals === void 0 ? void 0 : pollingIntervals[chainId]) !== null && _a !== void 0 ? _a : pollingInterval;\n  }, [pollingInterval, pollingIntervals]);\n  useEffect(() => {\n    setProviders(Object.assign(Object.assign({}, getProvidersFromConfig(readOnlyUrls)), providerOverrides));\n  }, Object.entries(readOnlyUrls).flat());\n  useEffect(() => {\n    for (const [chainId] of Object.entries(readOnlyUrls)) {\n      const provider = providers[chainId];\n      if (provider && !isWebSocketProvider(provider)) {\n        provider.polling = isActive;\n      }\n    }\n  }, [isActive, providers, readOnlyUrls]);\n  useEffect(() => {\n    for (const [chainId, provider] of Object.entries(providers)) {\n      if (!isWebSocketProvider(provider)) {\n        provider.pollingInterval = getPollingInterval(Number(chainId));\n      }\n    }\n  }, [providers, getPollingInterval]);\n  const networks = useMemo(() => ({\n    providers,\n    updateNetworkState: dispatchNetworkState,\n    networkStates\n  }), [providers, dispatchNetworkState, networkStates]);\n  return _jsx(ReadonlyNetworksContext.Provider, Object.assign({\n    value: networks\n  }, {\n    children: children\n  }));\n}","map":{"version":3,"mappings":"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","names":["useCallback","useEffect","useMemo","useReducer","useState","providers","useConfig","ReadonlyNetworksContext","fromEntries","networkStatesReducer","useWindow","isWebSocketProvider","Provider","StaticJsonRpcProvider","getProviderFromConfig","urlOrProviderOrProviderFunction","isProvider","getProvidersFromConfig","readOnlyUrls","Object","entries","map","chainId","ReadonlyNetworksProvider","providerOverrides","children","pollingInterval","pollingIntervals","isActive","setProviders","networkStates","dispatchNetworkState","keys","errors","getPollingInterval","flat","provider","polling","Number","networks","updateNetworkState","_jsx","value"],"sources":["/Users/jaleltounsi/Documents/GitHub/apexwave.fi/apexwave/node_modules/@usedapp/core/src/providers/network/readonlyNetworks/provider.tsx"],"sourcesContent":["import { ReactNode, useCallback, useEffect, useMemo, useReducer, useState } from 'react'\nimport { providers } from 'ethers'\nimport { useConfig } from '../../../hooks'\nimport { Providers } from './model'\nimport { ReadonlyNetworksContext } from './context'\nimport { BaseProviderFactory, ChainId, NodeUrls } from '../../../constants'\nimport { fromEntries } from '../../../helpers/fromEntries'\nimport { networkStatesReducer } from './reducer'\nimport { useWindow } from '../../window'\nimport { isWebSocketProvider } from '../../../helpers'\n\nconst { Provider, StaticJsonRpcProvider } = providers\ntype BaseProvider = providers.BaseProvider\n\ninterface NetworkProviderProps {\n  providerOverrides?: Providers\n  children?: ReactNode\n}\n\nconst getProviderFromConfig = (urlOrProviderOrProviderFunction: string | BaseProvider | BaseProviderFactory) => {\n  if (Provider.isProvider(urlOrProviderOrProviderFunction)) {\n    return urlOrProviderOrProviderFunction\n  }\n  if (typeof urlOrProviderOrProviderFunction === 'function') {\n    return urlOrProviderOrProviderFunction()\n  }\n  return new StaticJsonRpcProvider(urlOrProviderOrProviderFunction)\n}\n\nexport const getProvidersFromConfig = (readOnlyUrls: NodeUrls) =>\n  fromEntries(\n    Object.entries(readOnlyUrls).map(([chainId, urlOrProviderOrProviderFunction]) => [\n      chainId,\n      getProviderFromConfig(urlOrProviderOrProviderFunction),\n    ])\n  )\n\nexport function ReadonlyNetworksProvider({ providerOverrides = {}, children }: NetworkProviderProps) {\n  const { readOnlyUrls = {}, pollingInterval, pollingIntervals } = useConfig()\n  const isActive = useWindow()\n  const [providers, setProviders] = useState<Providers>(() => ({\n    ...getProvidersFromConfig(readOnlyUrls),\n    ...providerOverrides,\n  }))\n  const [networkStates, dispatchNetworkState] = useReducer(networkStatesReducer, {\n    ...fromEntries(Object.keys({ ...readOnlyUrls, ...providerOverrides }).map((chainId) => [chainId, { errors: [] }])),\n  })\n  const getPollingInterval = useCallback((chainId: number) => pollingIntervals?.[chainId] ?? pollingInterval, [\n    pollingInterval,\n    pollingIntervals,\n  ])\n\n  useEffect(() => {\n    setProviders({ ...getProvidersFromConfig(readOnlyUrls), ...providerOverrides })\n  }, Object.entries(readOnlyUrls).flat())\n\n  useEffect(() => {\n    for (const [chainId] of Object.entries(readOnlyUrls)) {\n      const provider = providers[(chainId as unknown) as ChainId]\n      if (provider && !isWebSocketProvider(provider)) {\n        provider.polling = isActive\n      }\n    }\n  }, [isActive, providers, readOnlyUrls])\n\n  useEffect(() => {\n    for (const [chainId, provider] of Object.entries(providers)) {\n      if (!isWebSocketProvider(provider)) {\n        provider.pollingInterval = getPollingInterval(Number(chainId))\n      }\n    }\n  }, [providers, getPollingInterval])\n\n  const networks = useMemo(\n    () => ({\n      providers,\n      updateNetworkState: dispatchNetworkState,\n      networkStates,\n    }),\n    [providers, dispatchNetworkState, networkStates]\n  )\n\n  return <ReadonlyNetworksContext.Provider value={networks}>{children}</ReadonlyNetworksContext.Provider>\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}