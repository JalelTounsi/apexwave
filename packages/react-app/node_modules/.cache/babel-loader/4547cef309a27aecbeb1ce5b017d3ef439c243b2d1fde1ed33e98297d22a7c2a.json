{"ast":null,"code":"/**\n * @internal Intended for internal use - use it on your own risk\n */\nexport function callsReducer() {\n  let state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  let action = arguments.length > 1 ? arguments[1] : undefined;\n  if (action.type === 'ADD_CALLS') {\n    return [...state, ...action.calls.map(call => Object.assign(Object.assign({}, call), {\n      address: call.address.toLowerCase()\n    }))];\n  } else if (action.type === 'UPDATE_CALLS') {\n    return state.map(call => {\n      if (call.chainId !== action.chainId || !action.updatedCalls.includes(call)) {\n        return call;\n      }\n      const blockNumber = action.blockNumber;\n      return Object.assign(Object.assign({}, call), {\n        lastUpdatedBlockNumber: blockNumber\n      });\n    });\n  } else {\n    let finalState = state;\n    for (const call of action.calls) {\n      const index = finalState.findIndex(x => x.address.toLowerCase() === call.address.toLowerCase() && x.data === call.data);\n      if (index !== -1) {\n        finalState = finalState.filter((_, i) => i !== index);\n      }\n    }\n    return finalState;\n  }\n}","map":{"version":3,"mappings":"AAmEA;;;AAGA,OAAM,SAAUA,YAAY,GAAsC;EAAA,IAArCC,4EAAmB,EAAE;EAAA,IAAEC,MAAc;EAChE,IAAIA,MAAM,CAACC,IAAI,KAAK,WAAW,EAAE;IAC/B,OAAO,CAAC,GAAGF,KAAK,EAAE,GAAGC,MAAM,CAACE,KAAK,CAACC,GAAG,CAAEC,IAAI,IAAKC,gCAAMD,IAAI;MAAEE,OAAO,EAAEF,IAAI,CAACE,OAAO,CAACC,WAAW;IAAE,EAAG,CAAC,CAAC;GACrG,MAAM,IAAIP,MAAM,CAACC,IAAI,KAAK,cAAc,EAAE;IACzC,OAAOF,KAAK,CAACI,GAAG,CAAEC,IAAI,IAAI;MACxB,IAAIA,IAAI,CAACI,OAAO,KAAKR,MAAM,CAACQ,OAAO,IAAI,CAACR,MAAM,CAACS,YAAY,CAACC,QAAQ,CAACN,IAAI,CAAC,EAAE;QAC1E,OAAOA,IAAI;;MAEb,MAAMO,WAAW,GAAGX,MAAM,CAACW,WAAW;MACtC,uCAAYP,IAAI;QAAEQ,sBAAsB,EAAED;MAAW;IACvD,CAAC,CAAC;GACH,MAAM;IACL,IAAIE,UAAU,GAAGd,KAAK;IACtB,KAAK,MAAMK,IAAI,IAAIJ,MAAM,CAACE,KAAK,EAAE;MAC/B,MAAMY,KAAK,GAAGD,UAAU,CAACE,SAAS,CAC/BC,CAAC,IAAKA,CAAC,CAACV,OAAO,CAACC,WAAW,EAAE,KAAKH,IAAI,CAACE,OAAO,CAACC,WAAW,EAAE,IAAIS,CAAC,CAACC,IAAI,KAAKb,IAAI,CAACa,IAAI,CACtF;MACD,IAAIH,KAAK,KAAK,CAAC,CAAC,EAAE;QAChBD,UAAU,GAAGA,UAAU,CAACK,MAAM,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKA,CAAC,KAAKN,KAAK,CAAC;;;IAGzD,OAAOD,UAAU;;AAErB","names":["callsReducer","state","action","type","calls","map","call","Object","address","toLowerCase","chainId","updatedCalls","includes","blockNumber","lastUpdatedBlockNumber","finalState","index","findIndex","x","data","filter","_","i"],"sources":["/Users/jaleltounsi/Documents/GitHub/apexwave.fi/apexwave/node_modules/@usedapp/core/src/providers/chainState/common/callsReducer.ts"],"sourcesContent":["import { ChainId } from '../../..'\n\n/**\n * @internal Intended for internal use - use it on your own risk\n */\nexport type Action = AddCall | RemoveCall | UpdateCall\n\n/**\n * Represents a single call on the blockchain that can be included in multicall.\n *\n * @public\n */\nexport interface RawCall {\n  /**\n   * address of a contract to call\n   */\n  address: string\n  /**\n   * calldata of the call that encodes function call\n   */\n  data: string\n  /**\n   * chain id of the chain to perform the call on\n   */\n  chainId: ChainId\n  /**\n   * Whether the call is static (not expected to change between calls). Used for optimizations.\n   */\n  isStatic?: boolean\n  /**\n   * number of last updated block\n   */\n  lastUpdatedBlockNumber?: number\n  /**\n   * number of blocks to wait before updating the call\n   */\n  refreshPerBlocks?: number\n}\n\n/**\n * @deprecated It's recommended to use RawCall instead\n * @internal Intended for internal use - use it on your own risk\n */\nexport interface ChainCall {\n  chainId?: ChainId\n  address: string\n  data: string\n}\n\ninterface AddCall {\n  type: 'ADD_CALLS'\n  calls: RawCall[]\n}\n\ninterface UpdateCall {\n  type: 'UPDATE_CALLS'\n  calls: RawCall[]\n  updatedCalls: RawCall[]\n  blockNumber: number\n  chainId: number\n}\n\ninterface RemoveCall {\n  type: 'REMOVE_CALLS'\n  calls: RawCall[]\n}\n\n/**\n * @internal Intended for internal use - use it on your own risk\n */\nexport function callsReducer(state: RawCall[] = [], action: Action) {\n  if (action.type === 'ADD_CALLS') {\n    return [...state, ...action.calls.map((call) => ({ ...call, address: call.address.toLowerCase() }))]\n  } else if (action.type === 'UPDATE_CALLS') {\n    return state.map((call) => {\n      if (call.chainId !== action.chainId || !action.updatedCalls.includes(call)) {\n        return call\n      }\n      const blockNumber = action.blockNumber\n      return { ...call, lastUpdatedBlockNumber: blockNumber }\n    })\n  } else {\n    let finalState = state\n    for (const call of action.calls) {\n      const index = finalState.findIndex(\n        (x) => x.address.toLowerCase() === call.address.toLowerCase() && x.data === call.data\n      )\n      if (index !== -1) {\n        finalState = finalState.filter((_, i) => i !== index)\n      }\n    }\n    return finalState\n  }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}