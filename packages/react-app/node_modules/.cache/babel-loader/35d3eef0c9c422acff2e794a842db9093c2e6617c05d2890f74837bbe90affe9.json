{"ast":null,"code":"export class Event {\n  constructor() {\n    this._listeners = new Set();\n    this._effects = new Set();\n  }\n  emit(data) {\n    for (const listener of Array.from(this._listeners)) {\n      void this._trigger(listener, data);\n    }\n  }\n  on(callback) {\n    this._listeners.add(callback);\n    if (this.listenerCount() === 1) {\n      this._runEffects();\n    }\n    return () => this.off(callback);\n  }\n  off(callback) {\n    this._listeners.delete(callback);\n    if (this.listenerCount() === 0) {\n      this._cleanupEffects();\n    }\n  }\n  listenerCount() {\n    return this._listeners.size;\n  }\n  addEffect(effect) {\n    const handle = {\n      effect,\n      cleanup: undefined\n    };\n    if (this.listenerCount() > 0) {\n      const cleanup = handle.effect();\n      if (typeof cleanup === 'function') {\n        handle.cleanup = cleanup;\n      }\n    }\n    this._effects.add(handle);\n    return () => {\n      var _a;\n      // eslint-disable-next-line no-unused-expressions\n      (_a = handle.cleanup) === null || _a === void 0 ? void 0 : _a.call(handle);\n      this._effects.delete(handle);\n    };\n  }\n  async _trigger(listener, data) {\n    try {\n      await waitImmediate(); // Acts like setImmediate but preserves the stack-trace.\n      listener(data);\n    } catch (error) {\n      // Stop error propagation.\n      throwUnhandledRejection(error);\n    }\n  }\n  _runEffects() {\n    for (const handle of Array.from(this._effects)) {\n      const cleanup = handle.effect();\n      if (typeof cleanup === 'function') {\n        handle.cleanup = cleanup;\n      }\n    }\n  }\n  _cleanupEffects() {\n    var _a;\n    for (const handle of Array.from(this._effects)) {\n      // eslint-disable-next-line no-unused-expressions\n      (_a = handle.cleanup) === null || _a === void 0 ? void 0 : _a.call(handle);\n      handle.cleanup = undefined;\n    }\n  }\n}\nfunction throwUnhandledRejection(error) {\n  setTimeout(() => {\n    throw error;\n  });\n}\n/**\n * Like setImmediate but for async/await API. Useful for preserving stack-traces.\n */\nconst waitImmediate = () => new Promise(resolve => setTimeout(resolve));","map":{"version":3,"mappings":"AAiBA,OAAM,MAAOA,KAAK;EAAlBC;IACmB,eAAU,GAAG,IAAIC,GAAG,EAAqB;IACzC,aAAQ,GAAG,IAAIA,GAAG,EAAsB;EA0E3D;EAxEEC,IAAI,CAACC,IAAO;IACV,KAAK,MAAMC,QAAQ,IAAIC,KAAK,CAACC,IAAI,CAAC,IAAI,CAACC,UAAU,CAAC,EAAE;MAClD,KAAK,IAAI,CAACC,QAAQ,CAACJ,QAAQ,EAAED,IAAI,CAAC;;EAEtC;EAEAM,EAAE,CAACC,QAA2B;IAC5B,IAAI,CAACH,UAAU,CAACI,GAAG,CAACD,QAAQ,CAAC;IAE7B,IAAI,IAAI,CAACE,aAAa,EAAE,KAAK,CAAC,EAAE;MAC9B,IAAI,CAACC,WAAW,EAAE;;IAGpB,OAAO,MAAM,IAAI,CAACC,GAAG,CAACJ,QAAQ,CAAC;EACjC;EAEAI,GAAG,CAACJ,QAA2B;IAC7B,IAAI,CAACH,UAAU,CAACQ,MAAM,CAACL,QAAQ,CAAC;IAEhC,IAAI,IAAI,CAACE,aAAa,EAAE,KAAK,CAAC,EAAE;MAC9B,IAAI,CAACI,eAAe,EAAE;;EAE1B;EAEAJ,aAAa;IACX,OAAO,IAAI,CAACL,UAAU,CAACU,IAAI;EAC7B;EAEAC,SAAS,CAACC,MAAc;IACtB,MAAMC,MAAM,GAAuB;MAAED,MAAM;MAAEE,OAAO,EAAEC;IAAS,CAAE;IAEjE,IAAI,IAAI,CAACV,aAAa,EAAE,GAAG,CAAC,EAAE;MAC5B,MAAMS,OAAO,GAAGD,MAAM,CAACD,MAAM,EAAE;MAC/B,IAAI,OAAOE,OAAO,KAAK,UAAU,EAAE;QACjCD,MAAM,CAACC,OAAO,GAAGA,OAAO;;;IAI5B,IAAI,CAACE,QAAQ,CAACZ,GAAG,CAACS,MAAM,CAAC;IACzB,OAAO,MAAK;;MACV;MACA,YAAM,CAACC,OAAO,sDAAI;MAClB,IAAI,CAACE,QAAQ,CAACR,MAAM,CAACK,MAAM,CAAC;IAC9B,CAAC;EACH;EAEQ,MAAMZ,QAAQ,CAACJ,QAA2B,EAAED,IAAO;IACzD,IAAI;MACF,MAAMqB,aAAa,EAAE,EAAC;MACtBpB,QAAQ,CAACD,IAAI,CAAC;KACf,CAAC,OAAOsB,KAAU,EAAE;MACnB;MACAC,uBAAuB,CAACD,KAAK,CAAC;;EAElC;EAEQZ,WAAW;IACjB,KAAK,MAAMO,MAAM,IAAIf,KAAK,CAACC,IAAI,CAAC,IAAI,CAACiB,QAAQ,CAAC,EAAE;MAC9C,MAAMF,OAAO,GAAGD,MAAM,CAACD,MAAM,EAAE;MAC/B,IAAI,OAAOE,OAAO,KAAK,UAAU,EAAE;QACjCD,MAAM,CAACC,OAAO,GAAGA,OAAO;;;EAG9B;EAEQL,eAAe;;IACrB,KAAK,MAAMI,MAAM,IAAIf,KAAK,CAACC,IAAI,CAAC,IAAI,CAACiB,QAAQ,CAAC,EAAE;MAC9C;MACA,YAAM,CAACF,OAAO,sDAAI;MAClBD,MAAM,CAACC,OAAO,GAAGC,SAAS;;EAE9B;;AAGF,SAASI,uBAAuB,CAACD,KAAY;EAC3CE,UAAU,CAAC,MAAK;IACd,MAAMF,KAAK;EACb,CAAC,CAAC;AACJ;AAEA;;;AAGA,MAAMD,aAAa,GAAG,MAAM,IAAII,OAAO,CAAEC,OAAO,IAAKF,UAAU,CAACE,OAAO,CAAC,CAAC","names":["Event","constructor","Set","emit","data","listener","Array","from","_listeners","_trigger","on","callback","add","listenerCount","_runEffects","off","delete","_cleanupEffects","size","addEffect","effect","handle","cleanup","undefined","_effects","waitImmediate","error","throwUnhandledRejection","setTimeout","Promise","resolve"],"sources":["/Users/jaleltounsi/Documents/GitHub/apexwave.fi/apexwave/node_modules/@usedapp/core/src/helpers/event.ts"],"sourcesContent":["export type Effect = () => (() => void) | undefined | void\n\n/**\n * Effect that's been added to a specific Event.\n */\ninterface MaterializedEffect {\n  effect: Effect\n  cleanup: (() => void) | undefined\n}\n\nexport interface ReadOnlyEvent<T> {\n  on: (cb: (data: T) => void) => () => void\n  off: (cb: (data: T) => void) => void\n  emit: (data: T) => void\n  addEffect: (effect: Effect) => () => void\n}\n\nexport class Event<T = void> implements ReadOnlyEvent<T> {\n  private readonly _listeners = new Set<(data: T) => void>()\n  private readonly _effects = new Set<MaterializedEffect>()\n\n  emit(data: T) {\n    for (const listener of Array.from(this._listeners)) {\n      void this._trigger(listener, data)\n    }\n  }\n\n  on(callback: (data: T) => void): () => void {\n    this._listeners.add(callback)\n\n    if (this.listenerCount() === 1) {\n      this._runEffects()\n    }\n\n    return () => this.off(callback)\n  }\n\n  off(callback: (data: T) => void) {\n    this._listeners.delete(callback)\n\n    if (this.listenerCount() === 0) {\n      this._cleanupEffects()\n    }\n  }\n\n  listenerCount() {\n    return this._listeners.size\n  }\n\n  addEffect(effect: Effect): () => void {\n    const handle: MaterializedEffect = { effect, cleanup: undefined }\n\n    if (this.listenerCount() > 0) {\n      const cleanup = handle.effect()\n      if (typeof cleanup === 'function') {\n        handle.cleanup = cleanup\n      }\n    }\n\n    this._effects.add(handle)\n    return () => {\n      // eslint-disable-next-line no-unused-expressions\n      handle.cleanup?.()\n      this._effects.delete(handle)\n    }\n  }\n\n  private async _trigger(listener: (data: T) => void, data: T) {\n    try {\n      await waitImmediate() // Acts like setImmediate but preserves the stack-trace.\n      listener(data)\n    } catch (error: any) {\n      // Stop error propagation.\n      throwUnhandledRejection(error)\n    }\n  }\n\n  private _runEffects() {\n    for (const handle of Array.from(this._effects)) {\n      const cleanup = handle.effect()\n      if (typeof cleanup === 'function') {\n        handle.cleanup = cleanup\n      }\n    }\n  }\n\n  private _cleanupEffects() {\n    for (const handle of Array.from(this._effects)) {\n      // eslint-disable-next-line no-unused-expressions\n      handle.cleanup?.()\n      handle.cleanup = undefined\n    }\n  }\n}\n\nfunction throwUnhandledRejection(error: Error) {\n  setTimeout(() => {\n    throw error\n  })\n}\n\n/**\n * Like setImmediate but for async/await API. Useful for preserving stack-traces.\n */\nconst waitImmediate = () => new Promise((resolve) => setTimeout(resolve))\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}