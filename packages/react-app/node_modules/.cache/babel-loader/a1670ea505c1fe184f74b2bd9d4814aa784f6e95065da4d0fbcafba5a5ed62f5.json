{"ast":null,"code":"import { useCallback, useEffect, useState } from 'react';\nimport { useNotificationsContext, useTransactionsContext } from '../providers';\nimport { BigNumber, Contract, errors, utils } from 'ethers';\nimport { buildSafeTransaction, getLatestNonce, GNOSIS_SAFE_ABI } from '../helpers/gnosisSafeUtils';\nimport { useEthers } from './useEthers';\nimport { waitForSafeTransaction } from '../helpers/gnosisSafeUtils';\n/**\n * @internal\n */\nexport async function estimateTransactionGasLimit(transactionRequest, signer, gasLimitBufferPercentage) {\n  if (!signer || !transactionRequest) {\n    return undefined;\n  }\n  try {\n    const estimatedGas = transactionRequest.gasLimit ? BigNumber.from(transactionRequest.gasLimit) : await signer.estimateGas(transactionRequest);\n    return estimatedGas === null || estimatedGas === void 0 ? void 0 : estimatedGas.mul(gasLimitBufferPercentage + 100).div(100);\n  } catch (err) {\n    console.error(err);\n    return undefined;\n  }\n}\n/**\n * @internal\n */\nexport async function estimateContractFunctionGasLimit(contractWithSigner, functionName, args, gasLimitBufferPercentage) {\n  try {\n    const estimatedGas = await contractWithSigner.estimateGas[functionName](...args);\n    const gasLimit = estimatedGas === null || estimatedGas === void 0 ? void 0 : estimatedGas.mul(gasLimitBufferPercentage + 100).div(100);\n    return gasLimit;\n  } catch (err) {\n    console.error(err);\n    return undefined;\n  }\n}\n/**\n * @internal\n */\nasync function isNonContractWallet(library, address) {\n  if (!library || !address) {\n    return true;\n  }\n  const code = await library.getCode(address);\n  return code === '0x';\n}\nconst isDroppedAndReplaced = e => (e === null || e === void 0 ? void 0 : e.code) === errors.TRANSACTION_REPLACED && (e === null || e === void 0 ? void 0 : e.replacement) && ((e === null || e === void 0 ? void 0 : e.reason) === 'repriced' || (e === null || e === void 0 ? void 0 : e.cancelled) === false);\nexport function usePromiseTransaction(chainId, options) {\n  const [state, setState] = useState({\n    status: 'None'\n  });\n  const {\n    addTransaction,\n    updateTransaction\n  } = useTransactionsContext();\n  const {\n    addNotification\n  } = useNotificationsContext();\n  const {\n    library,\n    account\n  } = useEthers();\n  let gnosisSafeContract = undefined;\n  useEffect(() => {\n    return () => {\n      gnosisSafeContract === null || gnosisSafeContract === void 0 ? void 0 : gnosisSafeContract.removeAllListeners();\n    };\n  }, [gnosisSafeContract]);\n  const resetState = useCallback(() => {\n    setState({\n      status: 'None'\n    });\n  }, [setState]);\n  const promiseTransaction = useCallback(async function (transactionPromise) {\n    let {\n      safeTransaction\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w;\n    if (!chainId) return;\n    let transaction = undefined;\n    try {\n      setState({\n        status: 'PendingSignature',\n        chainId\n      });\n      const result = (await isNonContractWallet(library, account)) ? await handleNonContractWallet(transactionPromise) : await handleContractWallet(transactionPromise, {\n        safeTransaction\n      });\n      transaction = result === null || result === void 0 ? void 0 : result.transaction;\n      return result === null || result === void 0 ? void 0 : result.receipt;\n    } catch (e) {\n      const parsedErrorCode = parseInt((_g = (_e = (_c = (_b = (_a = e.error) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.code) !== null && _c !== void 0 ? _c : (_d = e.error) === null || _d === void 0 ? void 0 : _d.code) !== null && _e !== void 0 ? _e : (_f = e.data) === null || _f === void 0 ? void 0 : _f.code) !== null && _g !== void 0 ? _g : e.code);\n      const errorCode = isNaN(parsedErrorCode) ? undefined : parsedErrorCode;\n      const errorHash = (_l = (_k = (_j = (_h = e === null || e === void 0 ? void 0 : e.error) === null || _h === void 0 ? void 0 : _h.data) === null || _j === void 0 ? void 0 : _j.originalError) === null || _k === void 0 ? void 0 : _k.data) !== null && _l !== void 0 ? _l : (_m = e === null || e === void 0 ? void 0 : e.error) === null || _m === void 0 ? void 0 : _m.data;\n      const errorMessage = (_v = (_t = (_s = (_q = (_p = (_o = e.error) === null || _o === void 0 ? void 0 : _o.data) === null || _p === void 0 ? void 0 : _p.message) !== null && _q !== void 0 ? _q : (_r = e.error) === null || _r === void 0 ? void 0 : _r.message) !== null && _s !== void 0 ? _s : e.reason) !== null && _t !== void 0 ? _t : (_u = e.data) === null || _u === void 0 ? void 0 : _u.message) !== null && _v !== void 0 ? _v : e.message;\n      if (transaction) {\n        const droppedAndReplaced = isDroppedAndReplaced(e);\n        if (droppedAndReplaced) {\n          const status = e.receipt.status === 0 ? 'Fail' : 'Success';\n          const type = status === 'Fail' ? 'transactionFailed' : 'transactionSucceed';\n          addNotification({\n            notification: {\n              type,\n              submittedAt: Date.now(),\n              transaction: e.replacement,\n              receipt: e.receipt,\n              transactionName: (_w = e.replacement) === null || _w === void 0 ? void 0 : _w.transactionName,\n              originalTransaction: transaction\n            },\n            chainId\n          });\n          setState({\n            status,\n            transaction: e.replacement,\n            originalTransaction: transaction,\n            receipt: e.receipt,\n            errorMessage,\n            errorCode,\n            errorHash,\n            chainId\n          });\n        } else {\n          setState({\n            status: 'Fail',\n            transaction,\n            receipt: e.receipt,\n            errorMessage,\n            errorCode,\n            errorHash,\n            chainId\n          });\n        }\n      } else {\n        setState({\n          status: 'Exception',\n          errorMessage,\n          errorCode,\n          errorHash,\n          chainId\n        });\n      }\n      return undefined;\n    }\n  }, [chainId, setState, addTransaction, options]);\n  const handleNonContractWallet = async transactionPromise => {\n    if (!chainId) return;\n    const transaction = await transactionPromise;\n    setState({\n      transaction,\n      status: 'Mining',\n      chainId\n    });\n    addTransaction({\n      transaction: Object.assign(Object.assign({}, transaction), {\n        chainId: chainId\n      }),\n      submittedAt: Date.now(),\n      transactionName: options === null || options === void 0 ? void 0 : options.transactionName\n    });\n    const receipt = await transaction.wait();\n    updateTransaction({\n      transaction: Object.assign(Object.assign({}, transaction), {\n        chainId: chainId\n      }),\n      receipt\n    });\n    setState({\n      receipt,\n      transaction,\n      status: 'Success',\n      chainId\n    });\n    return {\n      transaction,\n      receipt\n    };\n  };\n  const handleContractWallet = async function (transactionPromise) {\n    let {\n      safeTransaction\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _a;\n    if (!chainId || !library || !account) return;\n    setState({\n      status: 'CollectingSignaturePool',\n      chainId\n    });\n    gnosisSafeContract = new Contract(account, new utils.Interface(GNOSIS_SAFE_ABI), library);\n    const latestNonce = await getLatestNonce(chainId, account);\n    const safeTx = buildSafeTransaction({\n      to: (_a = safeTransaction === null || safeTransaction === void 0 ? void 0 : safeTransaction.to) !== null && _a !== void 0 ? _a : '',\n      value: safeTransaction === null || safeTransaction === void 0 ? void 0 : safeTransaction.value,\n      data: safeTransaction === null || safeTransaction === void 0 ? void 0 : safeTransaction.data,\n      nonce: latestNonce ? latestNonce + 1 : await gnosisSafeContract.nonce()\n    });\n    const {\n      transaction,\n      receipt,\n      rejected\n    } = await waitForSafeTransaction(transactionPromise, gnosisSafeContract, chainId, safeTx);\n    if (rejected) {\n      const errorMessage = 'On-chain rejection created';\n      addTransaction({\n        transaction: Object.assign(Object.assign({}, transaction), {\n          chainId: chainId\n        }),\n        receipt,\n        submittedAt: Date.now(),\n        transactionName: options === null || options === void 0 ? void 0 : options.transactionName\n      });\n      setState({\n        status: 'Fail',\n        transaction,\n        receipt,\n        errorMessage,\n        chainId\n      });\n    } else {\n      addTransaction({\n        transaction: Object.assign(Object.assign({}, transaction), {\n          chainId: chainId\n        }),\n        receipt,\n        submittedAt: Date.now(),\n        transactionName: options === null || options === void 0 ? void 0 : options.transactionName\n      });\n      setState({\n        receipt,\n        transaction,\n        status: 'Success',\n        chainId\n      });\n    }\n    return {\n      transaction,\n      receipt\n    };\n  };\n  return {\n    promiseTransaction,\n    state,\n    resetState\n  };\n}","map":{"version":3,"mappings":"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","names":["useCallback","useEffect","useState","useNotificationsContext","useTransactionsContext","BigNumber","Contract","errors","utils","buildSafeTransaction","getLatestNonce","GNOSIS_SAFE_ABI","useEthers","waitForSafeTransaction","estimateTransactionGasLimit","transactionRequest","signer","gasLimitBufferPercentage","undefined","estimatedGas","gasLimit","from","estimateGas","mul","div","err","console","error","estimateContractFunctionGasLimit","contractWithSigner","functionName","args","isNonContractWallet","library","address","code","getCode","isDroppedAndReplaced","e","TRANSACTION_REPLACED","replacement","reason","cancelled","usePromiseTransaction","chainId","options","state","setState","status","addTransaction","updateTransaction","addNotification","account","gnosisSafeContract","removeAllListeners","resetState","promiseTransaction","transactionPromise","safeTransaction","transaction","result","handleNonContractWallet","handleContractWallet","receipt","parsedErrorCode","parseInt","data","errorCode","isNaN","errorHash","originalError","errorMessage","message","droppedAndReplaced","type","notification","submittedAt","Date","now","transactionName","originalTransaction","wait","Interface","latestNonce","safeTx","to","value","nonce","rejected"],"sources":["/Users/jaleltounsi/Documents/GitHub/apexwave.fi/apexwave/node_modules/@usedapp/core/src/hooks/usePromiseTransaction.ts"],"sourcesContent":["import type { TransactionRequest, TransactionResponse } from '@ethersproject/abstract-provider'\nimport { useCallback, useEffect, useState } from 'react'\nimport { useNotificationsContext, useTransactionsContext } from '../providers'\nimport { TransactionStatus, TransactionOptions, TransactionState } from '../model'\nimport { BigNumber, Contract, errors, Signer, utils } from 'ethers'\nimport { buildSafeTransaction, getLatestNonce, GNOSIS_SAFE_ABI, SafeTransaction } from '../helpers/gnosisSafeUtils'\nimport { useEthers } from './useEthers'\nimport { waitForSafeTransaction } from '../helpers/gnosisSafeUtils'\nimport { JsonRpcProvider, FallbackProvider } from '@ethersproject/providers'\n\ninterface PromiseTransactionOpts {\n  safeTransaction?: Partial<SafeTransaction>\n}\n\n/**\n * @internal\n */\nexport async function estimateTransactionGasLimit(\n  transactionRequest: TransactionRequest | undefined,\n  signer: Signer | undefined,\n  gasLimitBufferPercentage: number\n) {\n  if (!signer || !transactionRequest) {\n    return undefined\n  }\n  try {\n    const estimatedGas = transactionRequest.gasLimit\n      ? BigNumber.from(transactionRequest.gasLimit)\n      : await signer.estimateGas(transactionRequest)\n    return estimatedGas?.mul(gasLimitBufferPercentage + 100).div(100)\n  } catch (err: any) {\n    console.error(err)\n    return undefined\n  }\n}\n\n/**\n * @internal\n */\nexport async function estimateContractFunctionGasLimit(\n  contractWithSigner: Contract,\n  functionName: string,\n  args: any[],\n  gasLimitBufferPercentage: number\n): Promise<BigNumber | undefined> {\n  try {\n    const estimatedGas = await contractWithSigner.estimateGas[functionName](...args)\n    const gasLimit = estimatedGas?.mul(gasLimitBufferPercentage + 100).div(100)\n    return gasLimit\n  } catch (err: any) {\n    console.error(err)\n    return undefined\n  }\n}\n\n/**\n * @internal\n */\nasync function isNonContractWallet(\n  library: JsonRpcProvider | FallbackProvider | undefined,\n  address: string | undefined\n) {\n  if (!library || !address) {\n    return true\n  }\n  const code = await library.getCode(address)\n  return code === '0x'\n}\n\nconst isDroppedAndReplaced = (e: any) =>\n  e?.code === errors.TRANSACTION_REPLACED && e?.replacement && (e?.reason === 'repriced' || e?.cancelled === false)\n\nexport function usePromiseTransaction(chainId: number | undefined, options?: TransactionOptions) {\n  const [state, setState] = useState<TransactionStatus>({ status: 'None' })\n  const { addTransaction, updateTransaction } = useTransactionsContext()\n  const { addNotification } = useNotificationsContext()\n  const { library, account } = useEthers()\n  let gnosisSafeContract: Contract | undefined = undefined\n\n  useEffect(() => {\n    return () => {\n      gnosisSafeContract?.removeAllListeners()\n    }\n  }, [gnosisSafeContract])\n\n  const resetState = useCallback(() => {\n    setState({ status: 'None' })\n  }, [setState])\n\n  const promiseTransaction = useCallback(\n    async (transactionPromise: Promise<TransactionResponse>, { safeTransaction }: PromiseTransactionOpts = {}) => {\n      if (!chainId) return\n      let transaction: TransactionResponse | undefined = undefined\n      try {\n        setState({ status: 'PendingSignature', chainId })\n\n        const result = (await isNonContractWallet(library, account))\n          ? await handleNonContractWallet(transactionPromise)\n          : await handleContractWallet(transactionPromise, { safeTransaction })\n        transaction = result?.transaction\n        return result?.receipt\n      } catch (e: any) {\n        const parsedErrorCode = parseInt(e.error?.data?.code ?? e.error?.code ?? e.data?.code ?? e.code)\n        const errorCode = isNaN(parsedErrorCode) ? undefined : parsedErrorCode\n        const errorHash = e?.error?.data?.originalError?.data ?? e?.error?.data\n        const errorMessage = e.error?.data?.message ?? e.error?.message ?? e.reason ?? e.data?.message ?? e.message\n        if (transaction) {\n          const droppedAndReplaced = isDroppedAndReplaced(e)\n\n          if (droppedAndReplaced) {\n            const status: TransactionState = e.receipt.status === 0 ? 'Fail' : 'Success'\n            const type = status === 'Fail' ? 'transactionFailed' : 'transactionSucceed'\n\n            addNotification({\n              notification: {\n                type,\n                submittedAt: Date.now(),\n                transaction: e.replacement,\n                receipt: e.receipt,\n                transactionName: e.replacement?.transactionName,\n                originalTransaction: transaction,\n              },\n              chainId,\n            })\n\n            setState({\n              status,\n              transaction: e.replacement,\n              originalTransaction: transaction,\n              receipt: e.receipt,\n              errorMessage,\n              errorCode,\n              errorHash,\n              chainId,\n            })\n          } else {\n            setState({ status: 'Fail', transaction, receipt: e.receipt, errorMessage, errorCode, errorHash, chainId })\n          }\n        } else {\n          setState({ status: 'Exception', errorMessage, errorCode, errorHash, chainId })\n        }\n        return undefined\n      }\n    },\n    [chainId, setState, addTransaction, options]\n  )\n\n  const handleNonContractWallet = async (transactionPromise: Promise<TransactionResponse>) => {\n    if (!chainId) return\n\n    const transaction = await transactionPromise\n\n    setState({ transaction, status: 'Mining', chainId })\n    addTransaction({\n      transaction: {\n        ...transaction,\n        chainId: chainId,\n      },\n      submittedAt: Date.now(),\n      transactionName: options?.transactionName,\n    })\n    const receipt = await transaction.wait()\n    updateTransaction({\n      transaction: {\n        ...transaction,\n        chainId: chainId,\n      },\n      receipt,\n    })\n    setState({ receipt, transaction, status: 'Success', chainId })\n    return { transaction, receipt }\n  }\n\n  const handleContractWallet = async (\n    transactionPromise: Promise<TransactionResponse>,\n    { safeTransaction }: PromiseTransactionOpts = {}\n  ) => {\n    if (!chainId || !library || !account) return\n    setState({ status: 'CollectingSignaturePool', chainId })\n\n    gnosisSafeContract = new Contract(account, new utils.Interface(GNOSIS_SAFE_ABI), library)\n\n    const latestNonce = await getLatestNonce(chainId, account)\n\n    const safeTx = buildSafeTransaction({\n      to: safeTransaction?.to ?? '',\n      value: safeTransaction?.value,\n      data: safeTransaction?.data,\n      nonce: latestNonce ? latestNonce + 1 : await gnosisSafeContract.nonce(),\n    })\n\n    const { transaction, receipt, rejected } = await waitForSafeTransaction(\n      transactionPromise,\n      gnosisSafeContract,\n      chainId,\n      safeTx\n    )\n\n    if (rejected) {\n      const errorMessage = 'On-chain rejection created'\n      addTransaction({\n        transaction: {\n          ...transaction,\n          chainId: chainId,\n        },\n        receipt,\n        submittedAt: Date.now(),\n        transactionName: options?.transactionName,\n      })\n      setState({\n        status: 'Fail',\n        transaction,\n        receipt,\n        errorMessage,\n        chainId,\n      })\n    } else {\n      addTransaction({\n        transaction: {\n          ...transaction,\n          chainId: chainId,\n        },\n        receipt,\n        submittedAt: Date.now(),\n        transactionName: options?.transactionName,\n      })\n      setState({ receipt, transaction, status: 'Success', chainId })\n    }\n    return { transaction, receipt }\n  }\n\n  return { promiseTransaction, state, resetState }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}