{"ast":null,"code":"import { decodeUint, wordLength, fail } from '../common';\nexport function decodeTryAggregate(calldata) {\n  // function tryAggregate(bool requireSuccess, tuple(address target, bytes callData)[] calls) public returns (tuple(bool success, bytes returnData)[])\n  const errorMethodId = '0x08c379a0';\n  if (calldata.startsWith(errorMethodId)) {\n    throw new Error('Multicall2 aggregate: call failed');\n  }\n  calldata = calldata.slice(2); // 'remove 0x prefix'\n  const getNumber = offset => decodeUint(calldata.slice(offset * wordLength, (offset + 1) * wordLength));\n  // The array offset must be 0x20 - nothing is before the array\n  if (getNumber(0) !== 0x20) {\n    fail();\n  }\n  const arraySize = getNumber(1);\n  const calls = [];\n  for (let i = 0; i < arraySize; i++) {\n    // offset of the call number i\n    const callOffset = 2 * getNumber(i + 2) + 2 * wordLength;\n    // position of the call if we split calldata in chunks of 32 bytes\n    const pos = callOffset / wordLength;\n    // returnData is encoded as a flag showing if the call was successful,\n    // data offset, which should be equal to 0x40, data length and the data itself\n    const successEncoded = getNumber(pos);\n    if (successEncoded !== 1 && successEncoded !== 0) {\n      fail();\n    }\n    const success = successEncoded === 1;\n    if (getNumber(pos + 1) !== 0x40) {\n      fail();\n    }\n    const returnDataOffset = (pos + 3) * wordLength;\n    const returnDataLength = getNumber(pos + 2);\n    const returnData = calldata.slice(returnDataOffset, returnDataOffset + 2 * returnDataLength);\n    const call = [success, '0x' + returnData];\n    calls.push(call);\n  }\n  return [calls];\n}","map":{"version":3,"mappings":"AAAA,SAASA,UAAU,EAAEC,UAAU,EAAEC,IAAI,QAAQ,WAAW;AAExD,OAAM,SAAUC,kBAAkB,CAACC,QAAgB;EACjD;EACA,MAAMC,aAAa,GAAG,YAAY;EAClC,IAAID,QAAQ,CAACE,UAAU,CAACD,aAAa,CAAC,EAAE;IACtC,MAAM,IAAIE,KAAK,CAAC,mCAAmC,CAAC;;EAEtDH,QAAQ,GAAGA,QAAQ,CAACI,KAAK,CAAC,CAAC,CAAC,EAAC;EAC7B,MAAMC,SAAS,GAAIC,MAAc,IAAKV,UAAU,CAACI,QAAQ,CAACI,KAAK,CAACE,MAAM,GAAGT,UAAU,EAAE,CAACS,MAAM,GAAG,CAAC,IAAIT,UAAU,CAAC,CAAC;EAEhH;EACA,IAAIQ,SAAS,CAAC,CAAC,CAAC,KAAK,IAAI,EAAE;IACzBP,IAAI,EAAE;;EAER,MAAMS,SAAS,GAAGF,SAAS,CAAC,CAAC,CAAC;EAC9B,MAAMG,KAAK,GAAwB,EAAE;EAErC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,SAAS,EAAEE,CAAC,EAAE,EAAE;IAClC;IACA,MAAMC,UAAU,GAAG,CAAC,GAAGL,SAAS,CAACI,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,GAAGZ,UAAU;IACxD;IACA,MAAMc,GAAG,GAAGD,UAAU,GAAGb,UAAU;IACnC;IACA;IACA,MAAMe,cAAc,GAAGP,SAAS,CAACM,GAAG,CAAC;IACrC,IAAIC,cAAc,KAAK,CAAC,IAAIA,cAAc,KAAK,CAAC,EAAE;MAChDd,IAAI,EAAE;;IAER,MAAMe,OAAO,GAAGD,cAAc,KAAK,CAAC;IACpC,IAAIP,SAAS,CAACM,GAAG,GAAG,CAAC,CAAC,KAAK,IAAI,EAAE;MAC/Bb,IAAI,EAAE;;IAER,MAAMgB,gBAAgB,GAAG,CAACH,GAAG,GAAG,CAAC,IAAId,UAAU;IAC/C,MAAMkB,gBAAgB,GAAGV,SAAS,CAACM,GAAG,GAAG,CAAC,CAAC;IAC3C,MAAMK,UAAU,GAAGhB,QAAQ,CAACI,KAAK,CAACU,gBAAgB,EAAEA,gBAAgB,GAAG,CAAC,GAAGC,gBAAgB,CAAC;IAC5F,MAAME,IAAI,GAAsB,CAACJ,OAAO,EAAE,IAAI,GAAGG,UAAU,CAAC;IAC5DR,KAAK,CAACU,IAAI,CAACD,IAAI,CAAC;;EAElB,OAAO,CAACT,KAAK,CAAC;AAChB","names":["decodeUint","wordLength","fail","decodeTryAggregate","calldata","errorMethodId","startsWith","Error","slice","getNumber","offset","arraySize","calls","i","callOffset","pos","successEncoded","success","returnDataOffset","returnDataLength","returnData","call","push"],"sources":["/Users/jaleltounsi/Documents/GitHub/apexwave.fi/apexwave/node_modules/@usedapp/core/src/abi/multicall2/decoder.ts"],"sourcesContent":["import { decodeUint, wordLength, fail } from '../common'\n\nexport function decodeTryAggregate(calldata: string) {\n  // function tryAggregate(bool requireSuccess, tuple(address target, bytes callData)[] calls) public returns (tuple(bool success, bytes returnData)[])\n  const errorMethodId = '0x08c379a0'\n  if (calldata.startsWith(errorMethodId)) {\n    throw new Error('Multicall2 aggregate: call failed')\n  }\n  calldata = calldata.slice(2) // 'remove 0x prefix'\n  const getNumber = (offset: number) => decodeUint(calldata.slice(offset * wordLength, (offset + 1) * wordLength))\n\n  // The array offset must be 0x20 - nothing is before the array\n  if (getNumber(0) !== 0x20) {\n    fail()\n  }\n  const arraySize = getNumber(1)\n  const calls: [boolean, string][] = []\n\n  for (let i = 0; i < arraySize; i++) {\n    // offset of the call number i\n    const callOffset = 2 * getNumber(i + 2) + 2 * wordLength\n    // position of the call if we split calldata in chunks of 32 bytes\n    const pos = callOffset / wordLength\n    // returnData is encoded as a flag showing if the call was successful,\n    // data offset, which should be equal to 0x40, data length and the data itself\n    const successEncoded = getNumber(pos)\n    if (successEncoded !== 1 && successEncoded !== 0) {\n      fail()\n    }\n    const success = successEncoded === 1\n    if (getNumber(pos + 1) !== 0x40) {\n      fail()\n    }\n    const returnDataOffset = (pos + 3) * wordLength\n    const returnDataLength = getNumber(pos + 2)\n    const returnData = calldata.slice(returnDataOffset, returnDataOffset + 2 * returnDataLength)\n    const call: [boolean, string] = [success, '0x' + returnData]\n    calls.push(call)\n  }\n  return [calls]\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}