{"ast":null,"code":"import { decodeUint, fail, wordLength } from '../common';\nexport function decodeAggregate(calldata) {\n  // function aggregate(tuple(address target, bytes callData)[] calls) public returns (tuple(uint256 blockNumber, bytes returnData)[])\n  const errorMethodId = '0x08c379a0';\n  if (calldata.startsWith(errorMethodId)) {\n    throw new Error('Multicall aggregate: call failed');\n  }\n  calldata = calldata.slice(2); // 'remove 0x prefix'\n  const getNumber = offset => decodeUint(calldata.slice(offset * wordLength, (offset + 1) * wordLength));\n  const blockNumber = getNumber(0);\n  // The array offset must be 0x40 - blockNumber + array offset\n  if (getNumber(1) !== 0x40) {\n    fail();\n  }\n  const arraySize = getNumber(2);\n  const calls = [];\n  for (let i = 0; i < arraySize; i++) {\n    // offset of the call number i\n    const callOffset = 2 * getNumber(i + 3) + 3 * wordLength; // * 2 because 1 byte = 2 chars\n    // position of the call if we split calldata in chunks of 32 bytes\n    const pos = callOffset / wordLength;\n    // returnData is encoded as its length and the data itself\n    const returnDataOffset = (pos + 1) * wordLength;\n    const returnDataLength = getNumber(pos);\n    const returnData = calldata.slice(returnDataOffset, returnDataOffset + 2 * returnDataLength); // * 2 because 1 byte = 2 chars\n    calls.push('0x' + returnData);\n  }\n  return [blockNumber, calls];\n}","map":{"version":3,"mappings":"AAAA,SAASA,UAAU,EAAEC,IAAI,EAAEC,UAAU,QAAQ,WAAW;AAExD,OAAM,SAAUC,eAAe,CAACC,QAAgB;EAC9C;EACA,MAAMC,aAAa,GAAG,YAAY;EAClC,IAAID,QAAQ,CAACE,UAAU,CAACD,aAAa,CAAC,EAAE;IACtC,MAAM,IAAIE,KAAK,CAAC,kCAAkC,CAAC;;EAErDH,QAAQ,GAAGA,QAAQ,CAACI,KAAK,CAAC,CAAC,CAAC,EAAC;EAC7B,MAAMC,SAAS,GAAIC,MAAc,IAAKV,UAAU,CAACI,QAAQ,CAACI,KAAK,CAACE,MAAM,GAAGR,UAAU,EAAE,CAACQ,MAAM,GAAG,CAAC,IAAIR,UAAU,CAAC,CAAC;EAEhH,MAAMS,WAAW,GAAGF,SAAS,CAAC,CAAC,CAAC;EAChC;EACA,IAAIA,SAAS,CAAC,CAAC,CAAC,KAAK,IAAI,EAAE;IACzBR,IAAI,EAAE;;EAER,MAAMW,SAAS,GAAGH,SAAS,CAAC,CAAC,CAAC;EAC9B,MAAMI,KAAK,GAAa,EAAE;EAE1B,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,SAAS,EAAEE,CAAC,EAAE,EAAE;IAClC;IACA,MAAMC,UAAU,GAAG,CAAC,GAAGN,SAAS,CAACK,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,GAAGZ,UAAU,EAAC;IACzD;IACA,MAAMc,GAAG,GAAGD,UAAU,GAAGb,UAAU;IACnC;IACA,MAAMe,gBAAgB,GAAG,CAACD,GAAG,GAAG,CAAC,IAAId,UAAU;IAC/C,MAAMgB,gBAAgB,GAAGT,SAAS,CAACO,GAAG,CAAC;IACvC,MAAMG,UAAU,GAAGf,QAAQ,CAACI,KAAK,CAACS,gBAAgB,EAAEA,gBAAgB,GAAG,CAAC,GAAGC,gBAAgB,CAAC,EAAC;IAC7FL,KAAK,CAACO,IAAI,CAAC,IAAI,GAAGD,UAAU,CAAC;;EAE/B,OAAO,CAACR,WAAW,EAAEE,KAAK,CAAC;AAC7B","names":["decodeUint","fail","wordLength","decodeAggregate","calldata","errorMethodId","startsWith","Error","slice","getNumber","offset","blockNumber","arraySize","calls","i","callOffset","pos","returnDataOffset","returnDataLength","returnData","push"],"sources":["/Users/jaleltounsi/Documents/GitHub/apexwave.fi/apexwave/node_modules/@usedapp/core/src/abi/multicall/decoder.ts"],"sourcesContent":["import { decodeUint, fail, wordLength } from '../common'\n\nexport function decodeAggregate(calldata: string): [number, string[]] {\n  // function aggregate(tuple(address target, bytes callData)[] calls) public returns (tuple(uint256 blockNumber, bytes returnData)[])\n  const errorMethodId = '0x08c379a0'\n  if (calldata.startsWith(errorMethodId)) {\n    throw new Error('Multicall aggregate: call failed')\n  }\n  calldata = calldata.slice(2) // 'remove 0x prefix'\n  const getNumber = (offset: number) => decodeUint(calldata.slice(offset * wordLength, (offset + 1) * wordLength))\n\n  const blockNumber = getNumber(0)\n  // The array offset must be 0x40 - blockNumber + array offset\n  if (getNumber(1) !== 0x40) {\n    fail()\n  }\n  const arraySize = getNumber(2)\n  const calls: string[] = []\n\n  for (let i = 0; i < arraySize; i++) {\n    // offset of the call number i\n    const callOffset = 2 * getNumber(i + 3) + 3 * wordLength // * 2 because 1 byte = 2 chars\n    // position of the call if we split calldata in chunks of 32 bytes\n    const pos = callOffset / wordLength\n    // returnData is encoded as its length and the data itself\n    const returnDataOffset = (pos + 1) * wordLength\n    const returnDataLength = getNumber(pos)\n    const returnData = calldata.slice(returnDataOffset, returnDataOffset + 2 * returnDataLength) // * 2 because 1 byte = 2 chars\n    calls.push('0x' + returnData)\n  }\n  return [blockNumber, calls]\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}