{"ast":null,"code":"import { useMemo } from 'react';\nimport { useRawLogs } from './useRawLogs';\nimport { decodeLogs, encodeFilterData } from '../helpers';\n/**\n * Makes a call to get the logs for a specific contract event and returns the decoded logs or an error if present.\n * The hook will cause the component to refresh when a new block is mined and the returned logs change.\n * A syntax sugar for {@link useRawLogs} that uses ABI, event name, and arguments instead of raw data.\n * @param filter an event filter (see {@link TypedFilter})\n * @param queryParams allows for additional configuration of the query (see {@link LogQueryParams})\n * @returns an array of decoded logs (see {@link LogsResult})\n * @public\n */\nexport function useLogs(filter) {\n  let queryParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    fromBlock,\n    toBlock,\n    blockHash\n  } = queryParams;\n  const rawFilter = useMemo(() => encodeFilterData(filter, fromBlock, toBlock, blockHash), [filter, fromBlock, toBlock, blockHash]);\n  const result = useRawLogs(rawFilter instanceof Error ? undefined : rawFilter, queryParams);\n  return useMemo(() => decodeLogs(filter, rawFilter instanceof Error ? rawFilter : result), [result, filter, rawFilter]);\n}","map":{"version":3,"mappings":"AAAA,SAASA,OAAO,QAAQ,OAAO;AAG/B,SAASC,UAAU,QAAQ,cAAc;AACzC,SAAqBC,UAAU,EAAEC,gBAAgB,QAAQ,YAAY;AAwBrE;;;;;;;;;AASA,OAAM,SAAUC,OAAO,CACrBC,MAAkC,EACF;EAAA,IAAhCC,kFAA8B,EAAE;EAEhC,MAAM;IAAEC,SAAS;IAAEC,OAAO;IAAEC;EAAS,CAAE,GAAGH,WAAW;EAErD,MAAMI,SAAS,GAAGV,OAAO,CAAC,MAAMG,gBAAgB,CAACE,MAAM,EAAEE,SAAS,EAAEC,OAAO,EAAEC,SAAS,CAAC,EAAE,CACvFJ,MAAM,EACNE,SAAS,EACTC,OAAO,EACPC,SAAS,CACV,CAAC;EACF,MAAME,MAAM,GAAGV,UAAU,CAACS,SAAS,YAAYE,KAAK,GAAGC,SAAS,GAAGH,SAAS,EAAEJ,WAAW,CAAC;EAC1F,OAAON,OAAO,CAAC,MAAME,UAAU,CAACG,MAAM,EAAEK,SAAS,YAAYE,KAAK,GAAGF,SAAS,GAAGC,MAAM,CAAC,EAAE,CAACA,MAAM,EAAEN,MAAM,EAAEK,SAAS,CAAC,CAAC;AACxH","names":["useMemo","useRawLogs","decodeLogs","encodeFilterData","useLogs","filter","queryParams","fromBlock","toBlock","blockHash","rawFilter","result","Error","undefined"],"sources":["/Users/jaleltounsi/Documents/GitHub/apexwave.fi/apexwave/node_modules/@usedapp/core/src/hooks/useLogs.ts"],"sourcesContent":["import { useMemo } from 'react'\nimport { Contract } from 'ethers'\nimport { ContractEventNames, Falsy, EventParams, TypedContract } from '../model/types'\nimport { useRawLogs } from './useRawLogs'\nimport { LogsResult, decodeLogs, encodeFilterData } from '../helpers'\nimport { LogQueryParams } from '../constants/type/QueryParams'\n\n/**\n * Represents a filter of logs emitted on a typed contract.\n * To be used with the {@link useLogs} hook.\n *\n * @public\n * @example\n * const filter: TypedFilter = {\n *   contract: token,\n *   event: 'Transfer',\n *   args: [null, deployer.address],\n * }\n */\nexport interface TypedFilter<\n  T extends TypedContract = Contract,\n  EN extends ContractEventNames<T> = ContractEventNames<T>\n> {\n  contract: T\n  event: EN\n  args: EventParams<T, EN>\n}\n\n/**\n * Makes a call to get the logs for a specific contract event and returns the decoded logs or an error if present.\n * The hook will cause the component to refresh when a new block is mined and the returned logs change.\n * A syntax sugar for {@link useRawLogs} that uses ABI, event name, and arguments instead of raw data.\n * @param filter an event filter (see {@link TypedFilter})\n * @param queryParams allows for additional configuration of the query (see {@link LogQueryParams})\n * @returns an array of decoded logs (see {@link LogsResult})\n * @public\n */\nexport function useLogs<T extends TypedContract = Contract, EN extends ContractEventNames<T> = ContractEventNames<T>>(\n  filter: TypedFilter<T, EN> | Falsy,\n  queryParams: LogQueryParams = {}\n): LogsResult<T, EN> {\n  const { fromBlock, toBlock, blockHash } = queryParams\n\n  const rawFilter = useMemo(() => encodeFilterData(filter, fromBlock, toBlock, blockHash), [\n    filter,\n    fromBlock,\n    toBlock,\n    blockHash,\n  ])\n  const result = useRawLogs(rawFilter instanceof Error ? undefined : rawFilter, queryParams)\n  return useMemo(() => decodeLogs(filter, rawFilter instanceof Error ? rawFilter : result), [result, filter, rawFilter])\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}