{"ast":null,"code":"import { jsx as _jsx } from \"react/jsx-runtime\";\nimport { useCallback, useEffect, useReducer } from 'react';\nimport { useEthers, useLocalStorage, useConfig } from '../../hooks';\nimport { useIsMounted } from '../../hooks/useIsMounted';\nimport { useNotificationsContext } from '../notifications/context';\nimport { TransactionsContext } from './context';\nimport { DEFAULT_STORED_TRANSACTIONS } from './model';\nimport { transactionReducer } from './reducer';\nexport function TransactionProvider(_ref) {\n  let {\n    children\n  } = _ref;\n  const {\n    chainId,\n    library\n  } = useEthers();\n  const {\n    localStorage\n  } = useConfig();\n  const [storage, setStorage] = useLocalStorage(localStorage.transactionPath);\n  const [transactions, dispatch] = useReducer(transactionReducer, storage !== null && storage !== void 0 ? storage : DEFAULT_STORED_TRANSACTIONS);\n  const {\n    addNotification\n  } = useNotificationsContext();\n  const isMounted = useIsMounted();\n  useEffect(() => {\n    setStorage(transactions);\n  }, [transactions]);\n  const addTransaction = useCallback(payload => {\n    if (!isMounted()) {\n      return;\n    }\n    dispatch({\n      type: 'ADD_TRANSACTION',\n      payload\n    });\n    if (payload.receipt) {\n      const type = payload.receipt.status === 0 ? 'transactionFailed' : 'transactionSucceed';\n      addNotification({\n        notification: {\n          type,\n          submittedAt: Date.now(),\n          transaction: payload.transaction,\n          receipt: payload.receipt,\n          transactionName: payload.transactionName\n        },\n        chainId: payload.transaction.chainId\n      });\n      return;\n    }\n    addNotification({\n      notification: {\n        type: 'transactionStarted',\n        transaction: payload.transaction,\n        submittedAt: payload.submittedAt,\n        transactionName: payload.transactionName\n      },\n      chainId: payload.transaction.chainId\n    });\n  }, [dispatch]);\n  const updateTransaction = useCallback(payload => {\n    if (!isMounted()) {\n      return;\n    }\n    dispatch({\n      type: 'UPDATE_TRANSACTION',\n      payload\n    });\n    const type = payload.receipt.status === 0 ? 'transactionFailed' : 'transactionSucceed';\n    addNotification({\n      notification: {\n        type,\n        submittedAt: Date.now(),\n        transaction: payload.transaction,\n        receipt: payload.receipt,\n        transactionName: payload.transactionName\n      },\n      chainId: payload.transaction.chainId\n    });\n  }, [dispatch]);\n  useEffect(() => {\n    const updateTransactions = async () => {\n      var _a;\n      if (!chainId || !library) return;\n      const blockNumber = await library.getBlockNumber();\n      const checkTransaction = async tx => {\n        if (tx.receipt || !shouldCheck(blockNumber, tx)) {\n          return tx;\n        }\n        try {\n          const receipt = await library.getTransactionReceipt(tx.transaction.hash);\n          if (receipt) {\n            const type = receipt.status === 0 ? 'transactionFailed' : 'transactionSucceed';\n            addNotification({\n              notification: {\n                type,\n                submittedAt: Date.now(),\n                transaction: tx.transaction,\n                receipt,\n                transactionName: tx.transactionName\n              },\n              chainId\n            });\n            return Object.assign(Object.assign({}, tx), {\n              receipt\n            });\n          } else {\n            return Object.assign(Object.assign({}, tx), {\n              lastCheckedBlockNumber: blockNumber\n            });\n          }\n        } catch (error) {\n          console.error(`failed to check transaction hash: ${tx.transaction.hash}`, error);\n        }\n        return tx;\n      };\n      const chainTransactions = (_a = transactions[chainId]) !== null && _a !== void 0 ? _a : [];\n      const newTransactions = [];\n      for (const tx of chainTransactions) {\n        const newTransaction = await checkTransaction(tx);\n        newTransactions.push(newTransaction);\n      }\n      if (isMounted()) {\n        dispatch({\n          type: 'UPDATE_TRANSACTIONS',\n          chainId,\n          transactions: newTransactions\n        });\n      }\n    };\n    void updateTransactions();\n  }, [chainId, library]);\n  return _jsx(TransactionsContext.Provider, {\n    value: {\n      transactions,\n      addTransaction,\n      updateTransaction\n    },\n    children: children\n  });\n}\nfunction shouldCheck(blockNumber, tx) {\n  if (tx.receipt) {\n    return false;\n  }\n  if (!tx.lastCheckedBlockNumber) {\n    return true;\n  }\n  const blocksSinceCheck = blockNumber - tx.lastCheckedBlockNumber;\n  if (blocksSinceCheck < 1) {\n    return false;\n  }\n  const minutesPending = (Date.now() - tx.submittedAt) / 1000 / 60;\n  if (minutesPending > 60) {\n    // every 10 blocks if pending for longer than an hour\n    return blocksSinceCheck > 9;\n  }\n  if (minutesPending > 5) {\n    // every 3 blocks if pending more than 5 minutes\n    return blocksSinceCheck > 2;\n  }\n  // otherwise every block\n  return true;\n}","map":{"version":3,"mappings":"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","names":["useCallback","useEffect","useReducer","useEthers","useLocalStorage","useConfig","useIsMounted","useNotificationsContext","TransactionsContext","DEFAULT_STORED_TRANSACTIONS","transactionReducer","TransactionProvider","children","chainId","library","localStorage","storage","setStorage","transactionPath","transactions","dispatch","addNotification","isMounted","addTransaction","payload","type","receipt","status","notification","submittedAt","Date","now","transaction","transactionName","updateTransaction","updateTransactions","blockNumber","getBlockNumber","checkTransaction","tx","shouldCheck","getTransactionReceipt","hash","lastCheckedBlockNumber","error","console","chainTransactions","newTransactions","newTransaction","push","_jsx","Provider","value","blocksSinceCheck","minutesPending"],"sources":["/Users/jaleltounsi/Documents/GitHub/apexwave.fi/apexwave/node_modules/@usedapp/core/src/providers/transactions/provider.tsx"],"sourcesContent":["import { ReactNode, useCallback, useEffect, useReducer } from 'react'\nimport { useEthers, useLocalStorage, useConfig } from '../../hooks'\nimport { useIsMounted } from '../../hooks/useIsMounted'\nimport { useNotificationsContext } from '../notifications/context'\nimport { TransactionsContext } from './context'\nimport { DEFAULT_STORED_TRANSACTIONS, StoredTransaction, UpdatedTransaction } from './model'\nimport { transactionReducer } from './reducer'\n\ninterface Props {\n  children: ReactNode\n}\n\nexport function TransactionProvider({ children }: Props) {\n  const { chainId, library } = useEthers()\n  const { localStorage } = useConfig()\n  const [storage, setStorage] = useLocalStorage(localStorage.transactionPath)\n  const [transactions, dispatch] = useReducer(transactionReducer, storage ?? DEFAULT_STORED_TRANSACTIONS)\n  const { addNotification } = useNotificationsContext()\n  const isMounted = useIsMounted()\n\n  useEffect(() => {\n    setStorage(transactions)\n  }, [transactions])\n\n  const addTransaction = useCallback(\n    (payload: StoredTransaction) => {\n      if (!isMounted()) {\n        return\n      }\n      dispatch({\n        type: 'ADD_TRANSACTION',\n        payload,\n      })\n      if (payload.receipt) {\n        const type = payload.receipt.status === 0 ? 'transactionFailed' : 'transactionSucceed'\n        addNotification({\n          notification: {\n            type,\n            submittedAt: Date.now(),\n            transaction: payload.transaction,\n            receipt: payload.receipt,\n            transactionName: payload.transactionName,\n          },\n          chainId: payload.transaction.chainId,\n        })\n        return\n      }\n      addNotification({\n        notification: {\n          type: 'transactionStarted',\n          transaction: payload.transaction,\n          submittedAt: payload.submittedAt,\n          transactionName: payload.transactionName,\n        },\n        chainId: payload.transaction.chainId,\n      })\n    },\n    [dispatch]\n  )\n\n  const updateTransaction = useCallback(\n    (payload: UpdatedTransaction) => {\n      if (!isMounted()) {\n        return\n      }\n      dispatch({\n        type: 'UPDATE_TRANSACTION',\n        payload,\n      })\n      const type = payload.receipt.status === 0 ? 'transactionFailed' : 'transactionSucceed'\n      addNotification({\n        notification: {\n          type,\n          submittedAt: Date.now(),\n          transaction: payload.transaction,\n          receipt: payload.receipt,\n          transactionName: payload.transactionName,\n        },\n        chainId: payload.transaction.chainId,\n      })\n    },\n    [dispatch]\n  )\n  useEffect(() => {\n    const updateTransactions = async () => {\n      if (!chainId || !library) return\n\n      const blockNumber = await library.getBlockNumber()\n\n      const checkTransaction = async (tx: StoredTransaction) => {\n        if (tx.receipt || !shouldCheck(blockNumber, tx)) {\n          return tx\n        }\n\n        try {\n          const receipt = await library.getTransactionReceipt(tx.transaction.hash)\n          if (receipt) {\n            const type = receipt.status === 0 ? 'transactionFailed' : 'transactionSucceed'\n            addNotification({\n              notification: {\n                type,\n                submittedAt: Date.now(),\n                transaction: tx.transaction,\n                receipt,\n                transactionName: tx.transactionName,\n              },\n              chainId,\n            })\n\n            return { ...tx, receipt }\n          } else {\n            return { ...tx, lastCheckedBlockNumber: blockNumber }\n          }\n        } catch (error) {\n          console.error(`failed to check transaction hash: ${tx.transaction.hash}`, error)\n        }\n\n        return tx\n      }\n\n      const chainTransactions = transactions[chainId] ?? []\n      const newTransactions: StoredTransaction[] = []\n      for (const tx of chainTransactions) {\n        const newTransaction = await checkTransaction(tx)\n        newTransactions.push(newTransaction)\n      }\n\n      if (isMounted()) {\n        dispatch({ type: 'UPDATE_TRANSACTIONS', chainId, transactions: newTransactions })\n      }\n    }\n\n    void updateTransactions()\n  }, [chainId, library])\n\n  return (\n    <TransactionsContext.Provider value={{ transactions, addTransaction, updateTransaction }} children={children} />\n  )\n}\n\nfunction shouldCheck(blockNumber: number, tx: StoredTransaction): boolean {\n  if (tx.receipt) {\n    return false\n  }\n\n  if (!tx.lastCheckedBlockNumber) {\n    return true\n  }\n\n  const blocksSinceCheck = blockNumber - tx.lastCheckedBlockNumber\n  if (blocksSinceCheck < 1) {\n    return false\n  }\n\n  const minutesPending = (Date.now() - tx.submittedAt) / 1000 / 60\n  if (minutesPending > 60) {\n    // every 10 blocks if pending for longer than an hour\n    return blocksSinceCheck > 9\n  }\n\n  if (minutesPending > 5) {\n    // every 3 blocks if pending more than 5 minutes\n    return blocksSinceCheck > 2\n  }\n\n  // otherwise every block\n  return true\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}