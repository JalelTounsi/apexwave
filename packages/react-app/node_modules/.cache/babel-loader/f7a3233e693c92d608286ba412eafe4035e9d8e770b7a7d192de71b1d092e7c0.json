{"ast":null,"code":"import { encodeUint, bufPaddedLength, buffLength } from '../common';\nimport { ethersAbi, falseEncoded, trueEncoded } from './constants';\nconst selector = ethersAbi.getSighash('tryAggregate');\nexport function encodeCalls(start, calls) {\n  let res = start;\n  // the first offset is calls.length * 0x20 because the first\n  // item of a dynamic array starts after all offsets\n  let dynamicOffset = calls.length * 0x20;\n  // number of items in the array\n  res += encodeUint(calls.length);\n  for (const call of calls) {\n    // offset of the current call\n    res += encodeUint(dynamicOffset);\n    // offset for the next call - current offset\n    // + length of the current call\n    // + space taken by the current offset\n    // + the first item in the next tuple - address for the next call\n    // + space taken by the offset for the next call data\n    dynamicOffset += 3 * 0x20 + bufPaddedLength(call[1]);\n  }\n  for (const call of calls) {\n    // address + calldata offset\n    dynamicOffset = 0x40;\n    res += '000000000000000000000000' + call[0].slice(2).toLowerCase();\n    res += encodeUint(dynamicOffset);\n    // call data length\n    res += buffLength(call[1]).toString(16).padStart(64, '0');\n    // calldata\n    res += call[1].slice(2).padEnd(bufPaddedLength(call[1]) * 2, '0');\n  }\n  return res;\n}\nexport function encodeTryAggregate(b, calls) {\n  // function tryAggregate(bool requireSuccess, tuple(address target, bytes callData)[] calls) public returns (tuple(bool success, bytes returnData)[])\n  let res = selector;\n  // offset of the array is 0x40 because we need to\n  // encode requireSuccess flag and the offset itself\n  const dynamicOffset = 0x40;\n  res += b ? trueEncoded : falseEncoded;\n  res += encodeUint(dynamicOffset);\n  // encode dynamic array of calls\n  return encodeCalls(res, calls);\n}","map":{"version":3,"mappings":"AAAA,SAASA,UAAU,EAAEC,eAAe,EAAEC,UAAU,QAAQ,WAAW;AACnE,SAASC,SAAS,EAAEC,YAAY,EAAEC,WAAW,QAAQ,aAAa;AAElE,MAAMC,QAAQ,GAAGH,SAAS,CAACI,UAAU,CAAC,cAAc,CAAC;AAErD,OAAM,SAAUC,WAAW,CAACC,KAAa,EAAEC,KAAyB;EAClE,IAAIC,GAAG,GAAGF,KAAK;EACf;EACA;EACA,IAAIG,aAAa,GAAGF,KAAK,CAACG,MAAM,GAAG,IAAI;EACvC;EACAF,GAAG,IAAIX,UAAU,CAACU,KAAK,CAACG,MAAM,CAAC;EAC/B,KAAK,MAAMC,IAAI,IAAIJ,KAAK,EAAE;IACxB;IACAC,GAAG,IAAIX,UAAU,CAACY,aAAa,CAAC;IAChC;IACA;IACA;IACA;IACA;IACAA,aAAa,IAAI,CAAC,GAAG,IAAI,GAAGX,eAAe,CAACa,IAAI,CAAC,CAAC,CAAC,CAAC;;EAGtD,KAAK,MAAMA,IAAI,IAAIJ,KAAK,EAAE;IACxB;IACAE,aAAa,GAAG,IAAI;IACpBD,GAAG,IAAI,0BAA0B,GAAGG,IAAI,CAAC,CAAC,CAAC,CAACC,KAAK,CAAC,CAAC,CAAC,CAACC,WAAW,EAAE;IAClEL,GAAG,IAAIX,UAAU,CAACY,aAAa,CAAC;IAEhC;IACAD,GAAG,IAAIT,UAAU,CAACY,IAAI,CAAC,CAAC,CAAC,CAAC,CAACG,QAAQ,CAAC,EAAE,CAAC,CAACC,QAAQ,CAAC,EAAE,EAAE,GAAG,CAAC;IACzD;IACAP,GAAG,IAAIG,IAAI,CAAC,CAAC,CAAC,CAACC,KAAK,CAAC,CAAC,CAAC,CAACI,MAAM,CAAClB,eAAe,CAACa,IAAI,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,EAAE,GAAG,CAAC;;EAGnE,OAAOH,GAAG;AACZ;AAEA,OAAM,SAAUS,kBAAkB,CAACC,CAAU,EAAEX,KAAyB;EACtE;EACA,IAAIC,GAAG,GAAGL,QAAQ;EAElB;EACA;EACA,MAAMM,aAAa,GAAG,IAAI;EAC1BD,GAAG,IAAIU,CAAC,GAAGhB,WAAW,GAAGD,YAAY;EACrCO,GAAG,IAAIX,UAAU,CAACY,aAAa,CAAC;EAEhC;EACA,OAAOJ,WAAW,CAACG,GAAG,EAAED,KAAK,CAAC;AAChC","names":["encodeUint","bufPaddedLength","buffLength","ethersAbi","falseEncoded","trueEncoded","selector","getSighash","encodeCalls","start","calls","res","dynamicOffset","length","call","slice","toLowerCase","toString","padStart","padEnd","encodeTryAggregate","b"],"sources":["/Users/jaleltounsi/Documents/GitHub/apexwave.fi/apexwave/node_modules/@usedapp/core/src/abi/multicall2/encoder.ts"],"sourcesContent":["import { encodeUint, bufPaddedLength, buffLength } from '../common'\nimport { ethersAbi, falseEncoded, trueEncoded } from './constants'\n\nconst selector = ethersAbi.getSighash('tryAggregate')\n\nexport function encodeCalls(start: string, calls: [string, string][]) {\n  let res = start\n  // the first offset is calls.length * 0x20 because the first\n  // item of a dynamic array starts after all offsets\n  let dynamicOffset = calls.length * 0x20\n  // number of items in the array\n  res += encodeUint(calls.length)\n  for (const call of calls) {\n    // offset of the current call\n    res += encodeUint(dynamicOffset)\n    // offset for the next call - current offset\n    // + length of the current call\n    // + space taken by the current offset\n    // + the first item in the next tuple - address for the next call\n    // + space taken by the offset for the next call data\n    dynamicOffset += 3 * 0x20 + bufPaddedLength(call[1])\n  }\n\n  for (const call of calls) {\n    // address + calldata offset\n    dynamicOffset = 0x40\n    res += '000000000000000000000000' + call[0].slice(2).toLowerCase()\n    res += encodeUint(dynamicOffset)\n\n    // call data length\n    res += buffLength(call[1]).toString(16).padStart(64, '0')\n    // calldata\n    res += call[1].slice(2).padEnd(bufPaddedLength(call[1]) * 2, '0')\n  }\n\n  return res\n}\n\nexport function encodeTryAggregate(b: boolean, calls: [string, string][]) {\n  // function tryAggregate(bool requireSuccess, tuple(address target, bytes callData)[] calls) public returns (tuple(bool success, bytes returnData)[])\n  let res = selector\n\n  // offset of the array is 0x40 because we need to\n  // encode requireSuccess flag and the offset itself\n  const dynamicOffset = 0x40\n  res += b ? trueEncoded : falseEncoded\n  res += encodeUint(dynamicOffset)\n\n  // encode dynamic array of calls\n  return encodeCalls(res, calls)\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}