{"ast":null,"code":"import { useMemo } from 'react';\nimport { useChainCalls } from './useChainCalls';\nimport { useChainId } from './useChainId';\nfunction warnOnInvalidContractCall(call) {\n  console.warn(`Invalid contract call: address=${call && call.address} method=${call && call.method} args=${call && call.args}`);\n}\nfunction encodeCallData(call, chainId) {\n  if (!call) {\n    return undefined;\n  }\n  if (!call.address || !call.method) {\n    warnOnInvalidContractCall(call);\n    return undefined;\n  }\n  try {\n    return {\n      address: call.address,\n      data: call.abi.encodeFunctionData(call.method, call.args),\n      chainId\n    };\n  } catch (_a) {\n    warnOnInvalidContractCall(call);\n    return undefined;\n  }\n}\n/**\n * Makes a call to a specific contract and returns the value. The hook will cause the component to refresh when a new block is mined and the return value changes.\n * A syntax sugar for {@link useChainCall} that uses ABI, function name, and arguments instead of raw data.\n * @public\n * @param call a single call to a contract, also see {@link ContractCall}.\n * @deprecated It is recommended to use {@link useCall} instead of this method as it is deprecated.\n * @returns the result of a call or undefined if call didn't return yet.\n */\nexport function useContractCall(call) {\n  let queryParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return useContractCalls([call], queryParams)[0];\n}\n/**\n * Makes calls to specific contracts and returns values. The hook will cause the component to refresh when a new block is mined and the return values change.\n * A syntax sugar for {@link useChainCalls} that uses ABI, function name, and arguments instead of raw data.\n * @public\n * @param calls a list of contract calls , also see {@link ContractCall}.\n * @deprecated It is recommended to use {@link useCalls} instead of this method as it is deprecated.\n * @returns array of results. Undefined if call didn't return yet.\n */\nexport function useContractCalls(calls) {\n  let queryParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const chainId = useChainId({\n    queryParams\n  });\n  const rawCalls = useMemo(() => calls.map(call => chainId !== undefined ? encodeCallData(call, chainId) : undefined), [JSON.stringify(calls.map(call => {\n    var _a;\n    return call && {\n      address: (_a = call.address) === null || _a === void 0 ? void 0 : _a.toLowerCase(),\n      method: call.method,\n      args: call.args\n    };\n  })), chainId]);\n  const results = useChainCalls(rawCalls);\n  return useMemo(() => results.map((result, idx) => {\n    const call = calls[idx];\n    if (result === '0x') {\n      warnOnInvalidContractCall(call);\n      return undefined;\n    }\n    return call && result ? call.abi.decodeFunctionResult(call.method, result) : undefined;\n  }), [JSON.stringify(results)]);\n}","map":{"version":3,"mappings":"AACA,SAASA,OAAO,QAAQ,OAAO;AAK/B,SAASC,aAAa,QAAQ,iBAAiB;AAC/C,SAASC,UAAU,QAAQ,cAAc;AAEzC,SAASC,yBAAyB,CAACC,IAA0B;EAC3DC,OAAO,CAACC,IAAI,CACV,kCAAkCF,IAAI,IAAIA,IAAI,CAACG,OAAO,WAAWH,IAAI,IAAIA,IAAI,CAACI,MAAM,SAASJ,IAAI,IAAIA,IAAI,CAACK,IAAI,EAAE,CACjH;AACH;AAEA,SAASC,cAAc,CAACN,IAA0B,EAAEO,OAAgB;EAClE,IAAI,CAACP,IAAI,EAAE;IACT,OAAOQ,SAAS;;EAElB,IAAI,CAACR,IAAI,CAACG,OAAO,IAAI,CAACH,IAAI,CAACI,MAAM,EAAE;IACjCL,yBAAyB,CAACC,IAAI,CAAC;IAC/B,OAAOQ,SAAS;;EAElB,IAAI;IACF,OAAO;MAAEL,OAAO,EAAEH,IAAI,CAACG,OAAO;MAAEM,IAAI,EAAET,IAAI,CAACU,GAAG,CAACC,kBAAkB,CAACX,IAAI,CAACI,MAAM,EAAEJ,IAAI,CAACK,IAAI,CAAC;MAAEE;IAAO,CAAE;GACrG,CAAC,WAAM;IACNR,yBAAyB,CAACC,IAAI,CAAC;IAC/B,OAAOQ,SAAS;;AAEpB;AA2BA;;;;;;;;AAQA,OAAM,SAAUI,eAAe,CAACZ,IAA0B,EAA+B;EAAA,IAA7Ba,kFAA2B,EAAE;EACvF,OAAOC,gBAAgB,CAAC,CAACd,IAAI,CAAC,EAAEa,WAAW,CAAC,CAAC,CAAC,CAAC;AACjD;AAEA;;;;;;;;AAQA,OAAM,SAAUC,gBAAgB,CAC9BC,KAA+B,EACF;EAAA,IAA7BF,kFAA2B,EAAE;EAE7B,MAAMN,OAAO,GAAGT,UAAU,CAAC;IAAEe;EAAW,CAAE,CAAC;EAE3C,MAAMG,QAAQ,GAAGpB,OAAO,CACtB,MAAMmB,KAAK,CAACE,GAAG,CAAEjB,IAAI,IAAMO,OAAO,KAAKC,SAAS,GAAGF,cAAc,CAACN,IAAI,EAAEO,OAAO,CAAC,GAAGC,SAAU,CAAC,EAC9F,CACEU,IAAI,CAACC,SAAS,CACZJ,KAAK,CAACE,GAAG,CAAEjB,IAAI,IAAI;IAAA;IAAC,WAAI,IAAI;MAAEG,OAAO,EAAE,UAAI,CAACA,OAAO,0CAAEiB,WAAW,EAAE;MAAEhB,MAAM,EAAEJ,IAAI,CAACI,MAAM;MAAEC,IAAI,EAAEL,IAAI,CAACK;IAAI,CAAE;EAAA,EAAC,CAC5G,EACDE,OAAO,CACR,CACF;EAED,MAAMc,OAAO,GAAGxB,aAAa,CAACmB,QAAQ,CAAC;EAEvC,OAAOpB,OAAO,CACZ,MACEyB,OAAO,CAACJ,GAAG,CAAC,CAACK,MAAM,EAAEC,GAAG,KAAI;IAC1B,MAAMvB,IAAI,GAAGe,KAAK,CAACQ,GAAG,CAAC;IACvB,IAAID,MAAM,KAAK,IAAI,EAAE;MACnBvB,yBAAyB,CAACC,IAAI,CAAC;MAC/B,OAAOQ,SAAS;;IAElB,OAAOR,IAAI,IAAIsB,MAAM,GAAItB,IAAI,CAACU,GAAG,CAACc,oBAAoB,CAACxB,IAAI,CAACI,MAAM,EAAEkB,MAAM,CAAW,GAAGd,SAAS;EACnG,CAAC,CAAC,EACJ,CAACU,IAAI,CAACC,SAAS,CAACE,OAAO,CAAC,CAAC,CAC1B;AACH","names":["useMemo","useChainCalls","useChainId","warnOnInvalidContractCall","call","console","warn","address","method","args","encodeCallData","chainId","undefined","data","abi","encodeFunctionData","useContractCall","queryParams","useContractCalls","calls","rawCalls","map","JSON","stringify","toLowerCase","results","result","idx","decodeFunctionResult"],"sources":["/Users/jaleltounsi/Documents/GitHub/apexwave.fi/apexwave/node_modules/@usedapp/core/src/hooks/useContractCall.ts"],"sourcesContent":["import { utils } from 'ethers'\nimport { useMemo } from 'react'\nimport { ChainId } from '../constants'\nimport { QueryParams } from '../constants/type/QueryParams'\nimport { Falsy } from '../model/types'\nimport { RawCall } from '../providers'\nimport { useChainCalls } from './useChainCalls'\nimport { useChainId } from './useChainId'\n\nfunction warnOnInvalidContractCall(call: ContractCall | Falsy) {\n  console.warn(\n    `Invalid contract call: address=${call && call.address} method=${call && call.method} args=${call && call.args}`\n  )\n}\n\nfunction encodeCallData(call: ContractCall | Falsy, chainId: ChainId): RawCall | Falsy {\n  if (!call) {\n    return undefined\n  }\n  if (!call.address || !call.method) {\n    warnOnInvalidContractCall(call)\n    return undefined\n  }\n  try {\n    return { address: call.address, data: call.abi.encodeFunctionData(call.method, call.args), chainId }\n  } catch {\n    warnOnInvalidContractCall(call)\n    return undefined\n  }\n}\n\n/**\n * Represents a single call to a contract that can be included in multicall.\n *\n * @public\n * @deprecated Use {@link useCall} instead.\n */\nexport interface ContractCall {\n  /**\n   * ABI of a contract, see [Interface](https://docs.ethers.io/v5/api/utils/abi/interface/)\n   */\n  abi: utils.Interface\n  /**\n   * address of a contract to call\n   */\n  address: string\n  /**\n   * function name\n   */\n  method: string\n  /**\n   * arguments for the function\n   */\n  args: any[]\n}\n\n/**\n * Makes a call to a specific contract and returns the value. The hook will cause the component to refresh when a new block is mined and the return value changes.\n * A syntax sugar for {@link useChainCall} that uses ABI, function name, and arguments instead of raw data.\n * @public\n * @param call a single call to a contract, also see {@link ContractCall}.\n * @deprecated It is recommended to use {@link useCall} instead of this method as it is deprecated.\n * @returns the result of a call or undefined if call didn't return yet.\n */\nexport function useContractCall(call: ContractCall | Falsy, queryParams: QueryParams = {}): any[] | undefined {\n  return useContractCalls([call], queryParams)[0]\n}\n\n/**\n * Makes calls to specific contracts and returns values. The hook will cause the component to refresh when a new block is mined and the return values change.\n * A syntax sugar for {@link useChainCalls} that uses ABI, function name, and arguments instead of raw data.\n * @public\n * @param calls a list of contract calls , also see {@link ContractCall}.\n * @deprecated It is recommended to use {@link useCalls} instead of this method as it is deprecated.\n * @returns array of results. Undefined if call didn't return yet.\n */\nexport function useContractCalls(\n  calls: (ContractCall | Falsy)[],\n  queryParams: QueryParams = {}\n): (any[] | undefined)[] {\n  const chainId = useChainId({ queryParams })\n\n  const rawCalls = useMemo(\n    () => calls.map((call) => (chainId !== undefined ? encodeCallData(call, chainId) : undefined)),\n    [\n      JSON.stringify(\n        calls.map((call) => call && { address: call.address?.toLowerCase(), method: call.method, args: call.args })\n      ),\n      chainId,\n    ]\n  )\n\n  const results = useChainCalls(rawCalls)\n\n  return useMemo(\n    () =>\n      results.map((result, idx) => {\n        const call = calls[idx]\n        if (result === '0x') {\n          warnOnInvalidContractCall(call)\n          return undefined\n        }\n        return call && result ? (call.abi.decodeFunctionResult(call.method, result) as any[]) : undefined\n      }),\n    [JSON.stringify(results)]\n  )\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}